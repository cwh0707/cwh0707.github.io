<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GNN概述</title>
    <url>/posts/40187/</url>
    <content><![CDATA[<h3 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h3><h4 id="如何将数据表示成图呢？"><a href="#如何将数据表示成图呢？" class="headerlink" title="如何将数据表示成图呢？"></a>如何将数据表示成图呢？</h4><ol>
<li>图片数据</li>
</ol>
<ol>
<li>文本数据</li>
</ol>
<ol>
<li>生活中例子</li>
</ol>
<ul>
<li>分子图</li>
</ul>
<ul>
<li>社交网络</li>
</ul>
<ul>
<li>引用图</li>
</ul>
<h4 id="图在研究什么问题？"><a href="#图在研究什么问题？" class="headerlink" title="图在研究什么问题？"></a>图在研究什么问题？</h4><ol>
<li>图结构层面的</li>
</ol>
<ol>
<li>顶点层面的</li>
</ol>
<ol>
<li>边层面的</li>
</ol>
<p>预测边的属性</p>
<h4 id="图需要解决问题会碰到的挑战"><a href="#图需要解决问题会碰到的挑战" class="headerlink" title="图需要解决问题会碰到的挑战"></a>图需要解决问题会碰到的挑战</h4><p>如何来表示我的图？从而使得我的图是可以和神经网络兼容的</p>
<p>边、顶点、全局信息、连接性 connectivity</p>
<p>要处理边，节点，全局信息的方法很简单，可以使用向量来表示即可，但是对于连接性来说，什么是连接性呢？就是说每条边到底连接的是哪两个点，可以很容易想到使用邻接矩阵来表示。想想可能出现的问题？</p>
<p>当矩阵特别大的话，那该如何来处理呢，稀疏矩阵。</p>
<p>当邻接矩阵四个顶点各种排序的话，那么就会依据排序会改变我的邻接矩阵，也就是会受到我的顺序的影响</p>
<p>解决办法：邻接列表的方式来处理</p>
<h3 id="图神经网络-GNN"><a href="#图神经网络-GNN" class="headerlink" title="图神经网络 GNN"></a>图神经网络 GNN</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>到底什么是图神经网络呢？我们是否可以用一句简单的话直白的表达它的核心思想呢？</p>
<p>答案是可以的，图神经网络是对图上的所有的属性进行一个可以优化的变换（这个变换是可以保存图的对称信息的）</p>
<p>输入：图 </p>
<p>输出：图</p>
]]></content>
      <categories>
        <category>研究生课程</category>
        <category>机器学习</category>
        <category>图神经网络GNN</category>
      </categories>
      <tags>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>bfs走迷宫问题</title>
    <url>/posts/25805/</url>
    <content><![CDATA[<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p>
<p>最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p>
<p>请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。</p>
<p>数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。</p>
<span id="more"></span>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p>
<p>接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h4 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h4><p>由于是需要求出最短路径，可以很容易地发现每条边的权值为1，可以很快地想到使用bfs，考虑这里是一个二维数组，在数据的存储上可能会有点差错，在这里为了熟悉模拟队列的操作，选择使用数组来模拟队列，只需要一个数组，一个队首指针hh和一个队尾tt即可，</p>
<p>bfs是具有模板的(概括一下)如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//初始化状态，刚开始队列为空，先将第一个元素放进队列中去,并让指针指向队列的下一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt) <span class="comment">//当队列不为空时</span></span><br><span class="line">    {</span><br><span class="line">     	<span class="comment">//取出队首元素</span></span><br><span class="line">        <span class="comment">//判断对应的条件</span></span><br><span class="line">        <span class="comment">//如果为true，那么将该元素置入队尾，并且将队尾指针往后移</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span> <span class="comment">//memset </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个队列</span></span><br><span class="line">PII q[N * N];</span><br><span class="line"><span class="comment">// 队首和队尾</span></span><br><span class="line"><span class="keyword">int</span> hh,tt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="comment">//存储每个点到（0,0）的距离distance</span></span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//初始化条件</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="comment">// 将原点放入到队首</span></span><br><span class="line">    q[<span class="number">0</span>] = {<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储上下左右四个方向</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)   <span class="comment">//当队列不为空时</span></span><br><span class="line">    {</span><br><span class="line">        PII t = q[hh ++];  <span class="comment">//取出队首元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = t.second + dy[i];</span><br><span class="line">            <span class="comment">//如果该处没有使用过 并且走的通的话</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; g[x][y] == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = {x, y}; <span class="comment">//将对应元素加入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g[i][j]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>ps：（也可以使用stl的queue来实现，会比数组模拟会好理解的多，明天再补，不能熬夜~，就酱紫）</p>
]]></content>
      <categories>
        <category>Acwing</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>Acwing</tag>
      </tags>
  </entry>
  <entry>
    <title>data mining 关联规则</title>
    <url>/posts/52112/</url>
    <content><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="frequent-Item-频繁项集"><a href="#frequent-Item-频繁项集" class="headerlink" title="frequent Item - 频繁项集"></a>frequent Item - 频繁项集</h3><p>项与项集： 设Itemset = {item_1，item_2，…item_n}是所有项的结集合</p>
<p>其中item_k(k=1,2,3,…n)被称为项，项的集合被称之为itemset</p>
<p>频繁项集：如果项集I的相对支持度满足实现定义好的最小支持度阈值，则I是频繁项集。</p>
<p>这个最小支持度阈值是自己给定的</p>
<h3 id="Support-支持度"><a href="#Support-支持度" class="headerlink" title="Support - 支持度"></a>Support - 支持度</h3><p>support of an association rule(关联规则的可信度)—-本质上来讲就是频率：</p>
<span id="more"></span>
<p>其中表示包含X和Y的并集的概率</p>
<script type="math/tex; mode=display">
Support(X \to Y) = \frac{(X \cup Y) }{n}</script><h3 id="Confidence-置信度"><a href="#Confidence-置信度" class="headerlink" title="Confidence  - 置信度"></a>Confidence  - 置信度</h3><script type="math/tex; mode=display">
Confidence(X \to Y) = \frac{ (X \cup Y)}{X}</script><p>从本质上来看，这个表达式与条件概率没有区别，就是计算一个先验概率</p>
<script type="math/tex; mode=display">
Confidence(X \to Y) = \frac{Support(X \cup Y)}{Support(X)}</script><p>条件概率公式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.742ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3422 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1140,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"/></g><g data-mml-node="mo" transform="translate(1903,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(2181,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mo" transform="translate(3033,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p>
<p>强关联规则：满足最小支持度和最小置信度的关联规则</p>
<h2 id="Aprior算法"><a href="#Aprior算法" class="headerlink" title="Aprior算法"></a>Aprior算法</h2><p>算法核心思路：</p>
<ul>
<li>一个频繁集中的所有想都必须是频繁项</li>
<li>一个不频繁项的超集都是不频繁的</li>
</ul>
<p>算法流程：</p>
<ul>
<li>找出所有的频繁项集</li>
<li>由频繁集产生强关联规则</li>
</ul>
<p>伪代码描述过程：</p>
<p><img src="/.io//1.jpg" alt="伪代码描述"></p>
<p>其中：Candidate为候选集，需要之前的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.562ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1132.4 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(714,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></g></svg></mjx-container>中挑出可靠的频繁集</p>
<p>python代码实现：</p>
<p>ps：在学习他人的代码的同时，也需要学习对应的代码书写规范，注释等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span>():</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    function: 构造原始数据</span></span><br><span class="line"><span class="string">    :return: 原始数据集合</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>[[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>],</span><br><span class="line">           [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>],</span><br><span class="line">           [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">           [<span class="string">'B'</span>, <span class="string">'E'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createC1</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    function: 将所有元素装换为frozenset型字典，并存放到列表中</span></span><br><span class="line"><span class="string">    :param dataSet:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> [item] <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item])</span><br><span class="line">    C1.sort()</span><br><span class="line">    <span class="comment"># 此处使用frozenset是为了可以讲这些值作为字典的键</span></span><br><span class="line">    <span class="comment"># frozenset为不可变集合，set为可变集合</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">frozenset</span>, C1))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanD</span>(<span class="params">D, Ck, minSupport</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    function：过滤掉不符合支持度的集合</span></span><br><span class="line"><span class="string">    实现：</span></span><br><span class="line"><span class="string">        遍历原始数据集合候选频繁项集，统计频繁项集汇中出现的次数</span></span><br><span class="line"><span class="string">        由此计算出支持度，再对比支持度是否满足要求</span></span><br><span class="line"><span class="string">        不满足的话则剔除，同时保留每个数据的支持度</span></span><br><span class="line"><span class="string">    :param D: 原始数据转换后的字典</span></span><br><span class="line"><span class="string">    :param Ck: 候选频繁项集</span></span><br><span class="line"><span class="string">    :param minSupport: 最小支持度</span></span><br><span class="line"><span class="string">    :return: 频繁项集列表retList 所有元素的支持度字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ssCnt = {}</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                <span class="keyword">if</span> can <span class="keyword">not</span> <span class="keyword">in</span> ssCnt:</span><br><span class="line">                    ssCnt[can] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ssCnt[can] += <span class="number">1</span></span><br><span class="line">    numItems = <span class="built_in">float</span>(<span class="built_in">len</span>(D))</span><br><span class="line">    retList = []</span><br><span class="line">    supportData = {}</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:</span><br><span class="line">        support = ssCnt[key] / numItems</span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>, key)</span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList, supportData  <span class="comment"># 排除不符合支持度元素后的元素 每个元素支持度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span>(<span class="params">Lk, k</span>) :</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    功能： 生成所有可以组合的集合</span></span><br><span class="line"><span class="string">    具体逻辑：通过每次比对频繁项集相邻的k-2个元素是否相等，如果相等就构造出一个新的集合</span></span><br><span class="line"><span class="string">    :param Lk: 频繁项集列表Lk</span></span><br><span class="line"><span class="string">    :param k: 项集元素个数k，当前组成项集的个数</span></span><br><span class="line"><span class="string">    :return: 频繁项集列表Ck</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    举例：[frozenset({2, 3}), frozenset({3, 5})] -&gt; [frozenset({2, 3, 5})]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = <span class="built_in">len</span>(Lk)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenLk) :  <span class="comment"># 两层循环比较Lk中的每个元素与其它元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, lenLk) :</span><br><span class="line">            L1 = <span class="built_in">list</span>(Lk[i])[:k - <span class="number">2</span>]  <span class="comment"># 将集合转为list后取值</span></span><br><span class="line">            L2 = <span class="built_in">list</span>(Lk[j])[:k - <span class="number">2</span>]</span><br><span class="line">            L1.sort();</span><br><span class="line">            L2.sort()  <span class="comment"># 这里说明一下：该函数每次比较两个list的前k-2个元素，如果相同则求并集得到k个元素的集合</span></span><br><span class="line">            <span class="keyword">if</span> L1 == L2 :</span><br><span class="line">                retList.append(Lk[i] | Lk[j])  <span class="comment"># 求并集</span></span><br><span class="line">    <span class="keyword">return</span> retList  <span class="comment"># 返回频繁项集列表Ck</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apriori</span>(<span class="params">dataSet, minSupport=<span class="number">0.5</span></span>) :</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    function：apriori算法实现</span></span><br><span class="line"><span class="string">    :param dataSet: 原始数据集合</span></span><br><span class="line"><span class="string">    :param minSupport: 最小支持度</span></span><br><span class="line"><span class="string">    :return: 所有满足大于阈值的组合 集合支持度列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    D = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">set</span>, dataSet))  <span class="comment"># 转换列表记录为字典，为了方便统计数据项出现的次数</span></span><br><span class="line">    C1 = createC1(dataSet)  <span class="comment"># 将每个元素转会为frozenset字典    [frozenset({A}), frozenset({B}), frozenset({C}), frozenset({D}), frozenset({E})]</span></span><br><span class="line">    <span class="comment"># 初始候选频繁项集合</span></span><br><span class="line">    L1, supportData = scanD(D, C1, minSupport)  <span class="comment"># 过滤数据,去除不满足最小支持度的项</span></span><br><span class="line">    <span class="comment"># L1 频繁项集列表 supportData 每个项集对应的支持度</span></span><br><span class="line">    L = [L1]</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(L[k - <span class="number">2</span>]) &gt; <span class="number">0</span>) :  <span class="comment"># 若仍有满足支持度的集合则继续做关联分析</span></span><br><span class="line">        Ck = aprioriGen(L[k - <span class="number">2</span>], k)  <span class="comment"># Ck候选频繁项集</span></span><br><span class="line">        Lk, supK = scanD(D, Ck, minSupport)  <span class="comment"># Lk频繁项集</span></span><br><span class="line">        supportData.update(supK)  <span class="comment"># 更新字典（把新出现的集合:支持度加入到supportData中）</span></span><br><span class="line">        L.append(Lk)</span><br><span class="line">        k += <span class="number">1</span>  <span class="comment"># 每次新组合的元素都只增加了一个，所以k也+1（k表示元素个数）</span></span><br><span class="line">    <span class="keyword">return</span> L, supportData</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcConf</span>(<span class="params">freqSet, H, supportData, brl, minConf=<span class="number">0.7</span></span>) :</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对规则进行评估 获得满足最小可信度的关联规则</span></span><br><span class="line"><span class="string">    :param freqSet: 集合元素大于两个的频繁项集</span></span><br><span class="line"><span class="string">    :param H:频繁项单个元素的集合列表</span></span><br><span class="line"><span class="string">    :param supportData:频繁项对应的支持度</span></span><br><span class="line"><span class="string">    :param brl:关联规则</span></span><br><span class="line"><span class="string">    :param minConf:最小可信度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    prunedH = []  <span class="comment"># 创建一个新的列表去返回</span></span><br><span class="line">    <span class="keyword">for</span> conseq <span class="keyword">in</span> H :</span><br><span class="line">        conf = supportData[freqSet] / supportData[freqSet - conseq]  <span class="comment"># 计算置信度</span></span><br><span class="line">        <span class="keyword">if</span> conf &gt;= minConf :</span><br><span class="line">            <span class="built_in">print</span>(freqSet - conseq,<span class="string">'--&gt;'</span>,conseq,<span class="string">'conf:'</span>,conf)</span><br><span class="line">            brl.append((freqSet - conseq, conseq, conf))</span><br><span class="line">            prunedH.append(conseq)</span><br><span class="line">    <span class="keyword">return</span> prunedH</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rulesFromConseq</span>(<span class="params">freqSet, H, supportData, brl, minConf=<span class="number">0.7</span></span>) :</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    功能：生成候选规则集合</span></span><br><span class="line"><span class="string">    :param freqSet: 集合元素大于两个的频繁项集</span></span><br><span class="line"><span class="string">    :param H:频繁项单个元素的集合列表</span></span><br><span class="line"><span class="string">    :param supportData:频繁项对应的支持度</span></span><br><span class="line"><span class="string">    :param brl:关联规则</span></span><br><span class="line"><span class="string">    :param minConf:最小可信度</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = <span class="built_in">len</span>(H[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(freqSet) &gt; (m + <span class="number">1</span>)) :  <span class="comment"># 尝试进一步合并</span></span><br><span class="line">        Hmp1 = aprioriGen(H, m + <span class="number">1</span>)  <span class="comment"># 将单个集合元素两两合并</span></span><br><span class="line">        Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(Hmp1) &gt; <span class="number">1</span>) :  <span class="comment"># need at least two sets to merge</span></span><br><span class="line">            rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRules</span>(<span class="params">L, supportData, minConf=<span class="number">0.7</span></span>) :</span>  <span class="comment"># supportData 是一个字典</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    功能：获取关联规则的封装函数</span></span><br><span class="line"><span class="string">    :param L:频繁项列表</span></span><br><span class="line"><span class="string">    :param supportData:每个频繁项对应的支持度</span></span><br><span class="line"><span class="string">    :param minConf:最小置信度</span></span><br><span class="line"><span class="string">    :return:强关联规则</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bigRuleList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(L)) :  <span class="comment"># 从为2个元素的集合开始</span></span><br><span class="line">        <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i] :</span><br><span class="line">            <span class="comment"># 只包含单个元素的集合列表</span></span><br><span class="line">            H1 = [<span class="built_in">frozenset</span>([item]) <span class="keyword">for</span> item <span class="keyword">in</span> freqSet]  <span class="comment"># frozenset({2, 3}) 转换为 [frozenset({2}), frozenset({3})]</span></span><br><span class="line">            <span class="comment"># 如果集合元素大于2个，则需要处理才能获得规则</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) :</span><br><span class="line">                rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf)  <span class="comment"># 集合元素 集合拆分后的列表 。。。</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                calcConf(freqSet, H1, supportData, bigRuleList, minConf)</span><br><span class="line">    <span class="keyword">return</span> bigRuleList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 初始化数据</span></span><br><span class="line">    dataSet = loadDataSet()</span><br><span class="line">    <span class="comment"># 计算出频繁项集合对应的支持度</span></span><br><span class="line">    L, suppData = apriori(dataSet,minSupport=<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"频繁项集："</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">list</span>(j))</span><br><span class="line">    <span class="comment"># 得出强关联规则</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"关联规则："</span>)</span><br><span class="line">    rules = generateRules(L, suppData, minConf=<span class="number">0.7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="/.io//2.png" alt="结果展示"></p>
<p><a href="https://blog.csdn.net/weixin_44106306/article/details/105978944">代码参考</a></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
        <category>关联规则</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>Aprior</tag>
      </tags>
  </entry>
  <entry>
    <title>data-mining-推荐算法</title>
    <url>/posts/4225/</url>
    <content><![CDATA[<h1 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h1><h3 id="tf"><a href="#tf" class="headerlink" title="tf"></a>tf</h3><p>首先思考一个问题，搜索一个关键词的时候，我们一般很快想到这个词在这个文本中出现的次数，如果次数多的话那么我们可以认为这个文本对于这个关键字来说是匹配的</p>
<p>故提出了TF概念，其实本质上来说就是单词在文本中出现的频率</p>
<span id="more"></span>
<script type="math/tex; mode=display">
tf(t,d) = \frac{n_{t,d}}{\sum_{k}n_{k,d}}</script><h3 id="idf"><a href="#idf" class="headerlink" title="idf"></a>idf</h3><p>再思考这么一个问题，仅仅考虑频率合理吗？例如一个文本中含有大量“我，的”这种词，而你的搜索词中正好也有这两个词的话，那么现在我们通常情况下都不会考虑这个频繁词，那么我们如何来实现这一件事情呢？于是人们提出了IDF的概念，用来抵消这一现象</p>
<script type="math/tex; mode=display">
idf(t,D) = log\frac{|D|}{| \{ d \in D:t\in d \}|}</script><p>其中分子<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex" xmlns="http://www.w3.org/2000/svg" width="3.131ex" height="2.26ex" role="img" focusable="false" viewbox="0 -749.5 1384 999"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g><g data-mml-node="mo" transform="translate(1106,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g></g></g></svg></mjx-container>指的是文档的个数，分母指的是包含关键字的文档的个数。举个例子来说，有两个文本，其中两个文本都有”的”，那么分子就是2，分母也是2，结果是1再取对数就是0。</p>
<h3 id="tf-idf"><a href="#tf-idf" class="headerlink" title="tf-idf"></a>tf-idf</h3><p>接下来就很简单了，该描述我们的TF-IDF了，所谓TF-IDF就是将TF和IDF进行一个相乘的运算，即</p>
<script type="math/tex; mode=display">
tf-idf = tf × idf</script><p>很明显从这个公式中我们可以知道，IDF它什么样的情况下会大呢，它希望这个关键词在我的文本出现的多并且在别的文档中出现的次数少，这样才会显得我的文本比别人的显得有特点。</p>
<h3 id="multiple-query-word"><a href="#multiple-query-word" class="headerlink" title="multiple query word"></a>multiple query word</h3><p>那么当出现了有多个查询呢，例如computer network，那么就对两个单词做拆分，分别计算每个单词的tf-idf，然后最后进行一个累加操作，非常简单</p>
<script type="math/tex; mode=display">
score = \sum_{t\in q}tf-idf(t,d,D)</script><h3 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h3><p>​    现在可以计算tf-idf了，接下来我们需要干什么呢？答案是将文本输入到计算机中去！但是计算机是理解不了我们的文本的呀，所以说有一个聪明的人他简单粗暴的将文本中含有多少个词，就对应与一个向量vector，例如这个文本中有10000个单词的话，那就直接将这个单词映射为10000维的向量，对其中的每一个单词上进行编码的话就是让对应的向量某一位为1，其它位为0，这样就可以表示这1万个向量，但是这种表示方法（词袋模型）很快就会出现许多问题，例如：</p>
<ul>
<li>如果单词数量非常多的话，那么这个维数就会非常高，在计算过程当中，就会平增许多复杂的计算</li>
<li>这种方法没有考虑单词与单词之间的关系，其实单词与单词之间是有关系，ont-hot编码方式直接认为各个单词之间是不相关的</li>
</ul>
<p>还有一种表示方法，就是将一篇文档映射成一个向量，我认为这个是借鉴了one-hot的思想，它将一篇文档假设有1000个关键词，如果当这个关键词存在的话，则在对应的位置上改变数字，这个数字可以是1，也可以是出现的次数，也可以是对应关键字的tf-idf值，这些都是可行的，可表示为 $p=(w<em>{1,p},w</em>{2,p},…,w_{t,p})$</p>
<p>当可以将文档表示为vector的话，那么就可以计算两篇文章的相似度了，在这里我们使用余弦相似度来计算，余弦相似度和欧式距离在本质上是没有区别的，因为在计算方式（公式上）上可以等同为两个比较是等价的：</p>
<script type="math/tex; mode=display">
sim(p,q) = cos(\theta)=\frac{p\cdot q}{|p|\cdot|q|}</script><p>​    这样可以对文档进行聚类，但是实际来说是非常困难的，为什么呢？因为会出现许多的同义词，例如poor recall和poor precision这两个问题，poor recall指的是例如对应于我想搜索一个car但是有很多vehicle的文章并没有给我显示出来，poor precision例如搜索一个apple，对应水果和apple公司，你如何去做抉择，给你的搜索用户返回对应的页面呢？是各自50篇？都具有各自的问题，对于这一种现象的处理，后面有学者研究出了矩阵分解的相关方法来处理。</p>
<h2 id="Latent-Semantic-Analysis-隐含语义分析"><a href="#Latent-Semantic-Analysis-隐含语义分析" class="headerlink" title="Latent Semantic Analysis  隐含语义分析"></a>Latent Semantic Analysis  隐含语义分析</h2><p>首先直接给出公式</p>
<script type="math/tex; mode=display">
X = TSD^T</script><p>其中的X就是term-document矩阵，然后对X进行分解，咋一看非常像奇异值分解，关于奇异值分解我后续也会出一篇文章讲解一下（先画饼），其中T是一个正交阵，D也是一个正交阵，S是一个对角阵（类似于特征值矩阵），X：m×n ；T：m×r；S：r×r；D：n×r；其中r=rank(X)</p>
<p>那么现在我们来计算<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="5.285ex" height="1.904ex" role="img" focusable="false" viewbox="0 -841.7 2336 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="msup" transform="translate(852,0)"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mi" transform="translate(936.2,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g></g></svg></mjx-container>将会等于一个什么值，其中会有很巧妙的tips</p>
<script type="math/tex; mode=display">
XX^T = (TSD^T)(TSD^T)^T = (TSD^TDS^TT^T)=T(SS^T)T^T
    = (TS)(TS)^T</script><p>很奇怪我们为什么想要计算<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="5.285ex" height="1.904ex" role="img" focusable="false" viewbox="0 -841.7 2336 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="msup" transform="translate(852,0)"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mi" transform="translate(936.2,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g></g></svg></mjx-container>这一个东东呢？其实我们可以通过矩阵计算来解释一下，对于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="5.285ex" height="1.904ex" role="img" focusable="false" viewbox="0 -841.7 2336 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="msup" transform="translate(852,0)"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mi" transform="translate(936.2,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g></g></svg></mjx-container>矩阵的第ij元素来说就是，第i个关键字与第j个关键字做了一个內积的和，这种的话我们从上面这个变换过程中可以看出，我们可以使用TS这一个矩阵替代掉原来的X矩阵，相当是使用了一个新的向量空间中的向量来替代对应的X矩阵，这个是对于term来说的，那如果我想对document也做一个类似这样的变化怎么搞？其实细心的人就会发现，只要将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="5.285ex" height="1.904ex" role="img" focusable="false" viewbox="0 -841.7 2336 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="msup" transform="translate(852,0)"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mi" transform="translate(936.2,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g></g></svg></mjx-container>反过来即可也就是计算<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="5.285ex" height="1.904ex" role="img" focusable="false" viewbox="0 -841.7 2336 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mi" transform="translate(936.2,363) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g><g data-mml-node="mi" transform="translate(1484,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g></g></g></svg></mjx-container>就能实现，现在还有一个问题，TS这个矩阵的维度和原来应该是一样的吗？</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
        <category>推荐算法</category>
      </categories>
      <tags>
        <tag>推荐算法</tag>
      </tags>
  </entry>
  <entry>
    <title>n-皇后问题</title>
    <url>/posts/23653/</url>
    <content><![CDATA[<p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p>
<p><img src="/.io//n-queue.png" alt="n-queens.png"></p>
<p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p>
<span id="more"></span>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含整数 n。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。</p>
<p>其中 <code>.</code> 表示某一个位置的方格状态为空，<code>Q</code> 表示某一个位置的方格上摆着皇后。</p>
<p>每个方案输出完成后，输出一个空行。</p>
<p><strong>注意：行末不能有多余空格。</strong></p>
<p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤9</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br></pre></td></tr></table></figure>
<h4 id="算法流程描述"><a href="#算法流程描述" class="headerlink" title="算法流程描述"></a>算法流程描述</h4><p>使用dfs暴力搜索</p>
<p><img src="/.io//算法过程.png" alt="算法过程"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">//dg代表对角线 udg代表反对角线 col代表列</span></span><br><span class="line"><span class="keyword">int</span> col[N],dg[N],udg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];  <span class="comment">//用来保存原来的棋盘</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>  <span class="comment">//u表示的是当前遍历的第u行元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( u==n )  <span class="comment">//说明遍历完成，输出存储的结果即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="comment">//%s 输出的是一维数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,g[i]); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当u&lt;n的时候</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分别对应于不同的对角线 u相当于x i相当于y 用截距</span></span><br><span class="line">        <span class="keyword">if</span>(col[i] == <span class="number">0</span> &amp;&amp; dg[i+u] == <span class="number">0</span> &amp;&amp; udg[n+i-u] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[i+u] = udg[n-u+i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            col[i] = dg[u+i] = udg[n-u+i] = <span class="number">0</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);  <span class="comment">//从第0行开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="解法二-按位搜索"><a href="#解法二-按位搜索" class="headerlink" title="解法二 按位搜索"></a>解法二 按位搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//q指代现在已经有多少个皇后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(y == n)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,g[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[y - x + n] &amp;&amp; !udg[y + x])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y+<span class="number">1</span>, q+<span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[y - x + n] = udg[y + x] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(x, y+<span class="number">1</span>， q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Acwing</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的图的存储</title>
    <url>/posts/39894/</url>
    <content><![CDATA[<h3 id="python中图的存储形式以及度的计算"><a href="#python中图的存储形式以及度的计算" class="headerlink" title="python中图的存储形式以及度的计算"></a>python中图的存储形式以及度的计算</h3><h4 id="邻接表的方式-（adjacency-list）"><a href="#邻接表的方式-（adjacency-list）" class="headerlink" title="邻接表的方式 （adjacency list）"></a>邻接表的方式 （adjacency list）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">filename = <span class="string">"sns_datasets/karate/karate_edges.txt"</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">34</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用邻接表的方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjacency_list</span>(<span class="params">filename</span>):</span></span><br><span class="line">    mydict = {}</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            temp_list = line.split()</span><br><span class="line">            start = temp_list[<span class="number">0</span>];</span><br><span class="line">            end = temp_list[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 存储start -&gt; end</span></span><br><span class="line">            <span class="keyword">if</span>(start <span class="keyword">not</span> <span class="keyword">in</span> mydict):</span><br><span class="line">                mydict[start] = []</span><br><span class="line">            start_list = mydict[start]</span><br><span class="line">            start_list.append(end)</span><br><span class="line">            mydict[start] = start_list</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 存储end结点 end -&gt; start</span></span><br><span class="line">            <span class="keyword">if</span>(end <span class="keyword">not</span> <span class="keyword">in</span> mydict):</span><br><span class="line">                mydict[end] = []</span><br><span class="line">            end_list = mydict[end]</span><br><span class="line">            end_list.append(start)</span><br><span class="line">            mydict[end] = end_list</span><br><span class="line">    <span class="built_in">print</span>(mydict)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#adjacency_list(filename)</span></span><br><span class="line">    <span class="comment">#adjacency_matric(filename)</span></span><br><span class="line">    get_degree(filename)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/Users/chenweiduo1512/Library/Application Support/typora-user-images/image-20211106111559797.png" alt="image-20211106111559797"></p>
<h4 id="邻接矩阵的形式-（adjacency-matrix）"><a href="#邻接矩阵的形式-（adjacency-matrix）" class="headerlink" title="邻接矩阵的形式 （adjacency matrix）"></a>邻接矩阵的形式 （adjacency matrix）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">filename = <span class="string">"sns_datasets/karate/karate_edges.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于无向图来说</span></span><br><span class="line">n = <span class="number">34</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjacency_matric</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="comment"># 使用邻接矩阵的形式必须要先初始化矩阵的大小</span></span><br><span class="line">    <span class="comment"># 如果在不知道矩阵的大小的时候，可以先算出来，就是里面结点的个数</span></span><br><span class="line">    adjacency_Matric = np.zeros((n,n))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            temp_list = line.split()</span><br><span class="line">            <span class="comment"># 对于一个无向图来说</span></span><br><span class="line">            adjacency_Matric[<span class="built_in">int</span>(temp_list[<span class="number">0</span>])-<span class="number">1</span>][<span class="built_in">int</span>(temp_list[<span class="number">1</span>])-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            adjacency_Matric[<span class="built_in">int</span>(temp_list[<span class="number">1</span>])-<span class="number">1</span>][<span class="built_in">int</span>(temp_list[<span class="number">0</span>])-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(adjacency_Matric)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/Users/chenweiduo1512/Library/Application Support/typora-user-images/image-20211106112454590.png" alt="image-20211106112454590"></p>
<h4 id="计算结点的度-compute-degree"><a href="#计算结点的度-compute-degree" class="headerlink" title="计算结点的度 compute degree"></a>计算结点的度 compute degree</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算结点的度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_degree</span>(<span class="params">filename</span>):</span></span><br><span class="line">    mydict = {}</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            temp_list = line.split()</span><br><span class="line">            start = temp_list[<span class="number">0</span>]</span><br><span class="line">            end = temp_list[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">not</span> <span class="keyword">in</span> mydict:</span><br><span class="line">                mydict[start] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> end <span class="keyword">not</span> <span class="keyword">in</span> mydict:</span><br><span class="line">                mydict[end] = <span class="number">0</span></span><br><span class="line">            mydict[start] += <span class="number">1</span></span><br><span class="line">            mydict[end] += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(mydict)</span><br></pre></td></tr></table></figure>
<h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="/Users/chenweiduo1512/Library/Application Support/typora-user-images/image-20211106112854921.png" alt="image-20211106112854921"></p>
]]></content>
      <categories>
        <category>-社交网络</category>
      </categories>
  </entry>
  <entry>
    <title>测试</title>
    <url>/posts/37773/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="1366adcf98866e465e20f6d6c9f2cdf5e58f2c080b211b4f6ebfde5528b4ebf6">dcc6d047d75edf5e860768b6d3a18fb85f55991a251c5760030dd480fc73a905678fa97252356003b0d2a8c48cd5463d8df6788a33e7ec11044afe07ec3833a849c68977b20002a25f5082880cce6c581439f62be07371fa4ea2db162034df2d8a29b004a2d3e08d288b10d211fcd40e37ebd47d5857ef82aa9d6b74769f8d660274f74e7c39d81d690dd54188161410840c1182a94173fdad3b84d9e257de843d797d08862978a83a3a324e5fc8021331a088cf3394c8e7fbc531fa609fa6a8478a9458a1eefbfa5bfaf79870a83a80e738de9602d493cb74a99f0f838da0733fea447dca409c716f34999c4c7c3bd79bc83b88f1f70d55049442a8c96faea5a669d585995bf0d9a0f3063084358aeee53e4594616a47f65299e1e6f74221302ebfaf77aa2283e9d504a55a049b6703e0efebaf83ada5ca77a94e87144ef2cf133e7bfbc71a87af1facbbe004a64a68bac3723a91c8b640e8062069eaa413b786be8d7c82787001eac9045b556ac54970636efc754cf0e20d93e81240cc7d7656883e71fc5d3118c7f4b65beefaca93d3821abb8c1724942421b354924c3cd228e2bcbd20b3920bf7a3005483909164fcb953e9681c6dce7f7bce4c2c030d51c36a2b59a7c782b65fba3957d6fba481358a971d469721fa9245280dd6320c1d0b9eab495fe89ba2f413172ef71b4076068dfa03b3045f1324ae5b7a4279844e05467da4e5de10090886417ea83011fdac74b9f296b97a62951af66eedbc2776f6906d678e807531c9d0557eeda2fa29f2daf765c6e12aa850a001092ac67452011dfd087d08870d0ed8cbf9d479431f443e9d926075f4810631c7a6b0180491f1cf7c6a96f72082690a86cd1e376ffdc23e6d941553b47c2934c55e17396dd76c3046fd430e63eb81927eb2e6f9a181674e92406913444e0952de767c9f4373ae536946d3b49da50fe99ffdb17c812d83ebedeb440caa4de20a2c80d4ebcf616d6121248a16e59262eace13e2d3de94f6af714dabe37a3b4068fb23b1bc8ba7c71c748f107dd697905c43756f0502c8f06db2875e05743a4043fedc41aba3b97ce7be196d8f970da29ec16c7b4e1ee288085750ab46d3ec5a5945353be9dfcf0907b6e21e22a51a76663ee07d9528b6ea731afd14cf79cada135324dabfe220b9cab8cd57632f0ac6c9f2fd800c58f4e4d5f0702f8fca8f3a41202916cea0a4fff4871e14cdab8d52e8c364a7697a2ceaa7f3b5addcf649a418efcd87a6d43097b6e765d4d96f4072784366107ec28e685bf9cabe786f6c516bae8f32d1296c0d848fbef0fe83f86ee07816708a8ff768319debd93f443f388a309913eaee48cfd424ea54ce306b87e898d6e44ef348ac00aa715e1be7ecbf66b0529119146be24cf605945cad4445ddb32e90d72af7242380f46313dcffb8f276055fef210e2be202d57441d027f6724856a091143f8a3d545aec95a69cd34badf77432d2d8a51c4efcbff89b53373c09246ee801ba2968095edc6814e60a1d9805b79129e8405beab3e33fa55bc02ff6fd052fdf56cd241b18bde98a2912ed687aaae6ad48a9e4d06456cf68881936e3dbf4754d542e460fdab6c9f7c4ac3df671aaabd8e91d8b8484ebcdacebbc6360ad23a351990d84e2e9c868c7451bdff8f04a81f4c2713b747c2ca07b86d440c0f2d997e0593cf37c305616b1e35765a5837ba7973dae083bec4dcd1d6a5ca3ec9d7697d04dee90a03151435c2a27a4893401cf98c0b1c5d768d529a65862777f321135474063ddd7c53f01d56435f7ae14e337004c99ec2cf42db709f312f3b6a2d05b931bee8827892315c61885bc4c8ca81d6fdaa0e5ac14e157df981851b785d0fdf7df4d5f05805caa2ce55dcccab39eff103b20d5f9de6a35557959d7bb047f6f643cdec0bdad0651aaded4992b931ae3f1f6c9c79e6954ac03efa1d64dae1a9c31eef9e8a4dbd8a82d95fc2f6c80700493cb49654b1f075235044e0cc05a8c9fef6dc759112d6813f7926336bc1c7c18df873a61035a12eb86ffad9e16f0d1656f8dc151482fa05c1a83513fedb4c93308af1b864c8e2a798270364d71137b18b1b7391b99145c42e88e0e6449139ef3d0884031445cae206a92cee129c44e679d833e4062a3c07a4d7016b570d05b27a70946abb35bfa20d8a33fa602ac20223f0b919de4a26fd33d5aaec2729c422a2b610410e854b3ed85339480334f3155007d91ca4dbf4116dd2f2cad276eca27c66664cef425f5a36d12dd7962a2eb06e0bb72f6abfbaf356944c178436ae5a651f0e27c2807da0f4455ac794c86af38d690d35158db6a1bd195ceb794775faf3028fbafc42fa09e620ceee9f36976542dced89e04f72b1cd7defc82dc13f15cec5adab591b7aab7a7e03f6b8d2e447276f0ad992f5a41a94c15d2d70a691fd6d7abc0072f92aeca9647a42a824293ffb3c2e168a64945cd4c2338079af29ec2369979e4399188ebee74bb9edbdbfe32cdf6ad854d951684658b1504bbc6dfae5989cb9943327e9723309645e5362c41ebdf4aff472d449a2aa5e4a5e358527eea6075d59648bc6351e0c9032fcc68b21b8feef31845c510521b8ef4dd4b637f2de79b96a49ff25bf28e3f1f3c8f6a0832c2f66c95e002386c95afc2395a2af0f42a254f51dcc04d1bfc06674f14a345e331d9e542c897de0bb6067d79a55994ff0f159603cc6fca029a0d7f0054c3a4fd593ec52da9918441602af9296af6c15caf7fbd3ad49eed7a4b41b0f587e01e2888278b20c2c89f8f4823c48deffedcd9f3125ad48cdff0187c47124512e8d5fbbc4c4d3790440f1c9dfda5e9333f9e088d5dd8be423f5c6885a652845acecbb745b85417247ca34904b378ef0d34a155b84ac764a3e33fc34b002390ec8341c14fbf565e976a78107a34f23a046c29b356b87da496a525126d52c7066181aaa6f33a03c92521eed12bf491cb44eaa39e59b918bb7615f57e1a673063c602c060899c1abc714454e79c0dd26e8445efd0db630582b44e576284ad775eba8293dad86e313b71c8a61637e8f943017723f1c50e5696548416ecf5167fc215a1b87d38b3f9599ca818c133d726dc429ebbd8986e26f04634803979b948e7fc8854619e48bf8918554591348b72f5506d317a50f778ae271c2fc62287f74f574b6b9cea4c39a05fca622c1d5cd6a2a9cf8eac1031480d2244463072dad58227874d7d5733aa6cca23f0ad10d09ab96c174c4fe5420ce3bd905c26fdf0bc94d5180fa990bbf16e12a1879bef5cd46b3926fafeb7de651cce6342a8dd75352f0b1936ad77858a8d14facd20a1988b9cf8a3e7178ee654dfa4090ad21646789b3ee21a2de791ac997a1d91905e614ef68e0cccbf9f7943103bcb17d63b22760cf7b923f3f5cee31b313994e1cdc4f5a85b2f9f7c9e2c6780292a70d975aa566de9ff3f277481a8eaddf5075ce13976ac01ef4feb69c6c20b1e23eb541ca56284b2c7e5cf32fe1b2d651ff88e1e25750bc823afd885aca1740e7fab586e8800d10a8d689afff8924f18edface12fb0c5ccf51cf6552046379ce8a7bb75adc98dfd7a37b7d84920fe2cfadcf40c25afc5cdde90fe0e4a791bc64365bfd792a7913dffaed5337e4ad242973ab49f09678fd709f326b1e8c61345d60c67ecafc1c5de727bba1f40cf83d652ab337326af7ce8c13ad7c8264385efb04f0204eae681c72a5bd5a4aabfb80a0036463f000ea7850933292b18b6223a1bc67d9babadfcd1004cf475d23cb0f56d55375a9b4b251d5806207f95877ba9b2f8dcd60c6007431230484f39caf61f6ebd932c0f64bb6e72c2901cd97c3b021a04682635bc4f6402f945f8ec105ce3491d3516adb865c2066b22bd4ee66f7aa21c5e4dd8e9d80edc5321a0cafb08a3dd71a6c75d5e951f8525b478dd3f2df9f0df3d1e0994943e8d401e89ed43ae8d6ea68c282473461c50b554b3471a898218fce79484cdfe2f96c3841011309acd434cb503d9ed65c9b903fc46eeac9c1c384494e2df131bcd9d8777c81ac2b456afdce4be75f94eafa0dae6beee191eb9b014bab44767311c6ebf0b0bd2b4535af2a890f1c007a14978628165e5265ba55947476644a133fee2fda6c5a91081d5b033363b28df6ddea1867f719da8b95067d316335c816c7376502594f46cc529f5f930c4371de25ae1fe52acfda836de210cbef560ff8b8bb42ba3466cf59126ffbe9df3cbad430fef84c0e31a6ae7e8f7a4a14299cf462bc1c4ddad38808cc3ac1229463a5eb660c882eba42f5bf25a85b22cf4b80e9a1a09847a4597dff6793cc959b64bfc575204aa94f4e03935ff15c651a1911842ad766ef85e26953392012fb3879c114ce48fdd7822bad632fce371bbb9258f0df83d8137293d2777d3c9cfacf56d5f32f2673af0f4da53b8e20616e14e4edf765fc5a802d3f6ec222fc5422413861b3e353f11e1b5cff6f773639c6fcb647ab00ee0ec64687aff593795d3ce30680f29a3959087eed3b3b2d89bc3196d65a2dd14622669ee3f48e31b5c0b181a74c4ff5ae961f271670fb8c75775609f4f520d4a656b0124c47a058c5a35dc961579cd0546799c61514b308e64a228927ca80ac58f824098ae0f9a29034535e006894289ee584eb01b2317caa40e7f7042b4a7072cd007d9493d105b1b0f3810319740f8d8dd7cf8b02131f6e58baa2e4a3375e2bea83127be4d7162855cd7fdfbce6dee93fd8da612763f2a605db7b3cd94208dcf7ecc0045e8e1a5a7b355d51691b3609ee611aee4ce3913d36204afa6e2fe98f74b59e792836946bdf3807bd32d9e38ef2beb3fe641ad9f6058e303f2124a412eb0aba0e0987f81ac332b67b9bc10907186f9abad6466c53e769f1f44d51fa4b719038195869b4728bda04637e2b60990fc9395951280c1c9f6cfffa6372ffd0a36686f3a1e53999312739bfdd5f457127216765aa59e02f24054b790c74f19fde8c4423919c2058a557075dc060ab8dc72094efbc28886f0158a2ae09436ae3ce1096d6674e7fdbfb04e2d603fd068a2a21a146927f28d6c6842fd5c3305ae9454ad0caa2ff075d2d5bca0f332298b8c7d034ce2f19eda54bf8e4a33f90bae86606b17f0b521ccd83f5188e6a0a4633cccc46adf64c627865ab776eaa5f9636a5b48d35d03a36c1be6824c9c6de62ba3decce595ee7f800065a06252b2de9bb49f8406301b9bdee0e2652324f6e7c097d65887bc275583f1cb8579dedca077d4e4854013f37825ae77109c51fe19ec2ba5679943f019e13bfea0a65d3f67ec95f27f1adfc498fd33f3e42a6132b836dd4cdfdba8c412cdde93a73d11afe022c2f52c3f50177c4c1a3af7ee6677577c0c4913e1f60ca8527c9b0510578d8e933116273663a3f3481a13058c0aaf50cf13b6714f8995def5b371533f60a9adae6d1b3dd43b4dd459160ab06c2675571644076cf8dfe1faab09d137802ce93d835f00db3b03baca5b1ac5150dbf6e0ee60e07f0fb05dc4103a7e13c60eb2a1ab406e70a2809490c4446e87a3e789e1715a396359bff7c7ac39a2ff2b47be0fdd156d9baa160171e177570cd3c63ebfdcb6af04671a3a0549974ab1927d4f93be6a59fc33601eabb22af4c5241816b2da0ec6c48c168652b7b57407cb6928a949068e35efbf7d9ea6a6c0853a1804249fcce9aefb1c737ce64901ace483be167efac49528cfe46b824f9cbdd03f0355d92445c8b4c03066919bbe3870f80edf8b5494c4217975c2404899028f00a2c67fa3af72c7d9d6b996e4e9e35c2d29acfb04fa7eefcddcb8f33fe004eb9b8fc1e44a04c26555ad35489842e8561506b8519a7faa4bc04514f9b50fcd0eee9be289420bdd3e28316c579a60e92bc28c72870ca733063ef2d7f60a13833f5615eb2ef69a0aaaab115cfca3bfdabda4e85f9bc153f8d59102fc12ae1fc2b9530e85844148fbcf44029a9399651c87c0bf7a60ea23841ea04f64df8436c1bb76d8696a5962491f2e168d43e39c46eda3cfe1150f5eae39c143ba470263b512462d84da1ef1e30a6b41ac65a6e881b90e527190b2d7714b21647857d26b4bea2eff251f4ed41bdc0540d0de0940cebf2f45b8c408595c3adbbd16141e8e0f4f086e6af2652a5ebd8042d5a5937857a9c767a8b7b62f4a704d18c89f3fb4f5d9ad31f6b73233772440fe08c3f2e32bc2a34157b9cd68ded738643de3d4f44209041c2765e71c3750a392508582661307732e92f4140aba1f52cf10ef96a50a2f1fb930a7828eee0904adef591f7e94f3c52eb4e1b2ba3ca3d554cf0cd20e757d70c2566b4a50e104c39919c64bdb9224e5cc33794a885bc9d109ef42d88548f783fcd2429a116cdc6fa7d0363f5f3c125eb01a333362e78075ef965466053fbb95c1050f88c175948fd8386175302cfc31db6d5e5ab8fd2f7a6a337cc462342235e9a263e776ec31d4cdea3354874d73c642287e49ce3c0ba9fb996c92eac596dbfa76a2d59157af25e29bbe7f221c1824fefbacefc649b562d070760d79a22de28eb92924ec5a49ffa321f57dc00aeba2694a42a0d6bffddd2c35241ecfb53343933c1c79775c7395ba95cecd3affa11510dababa9223b37ba56ff3f5e043f4c7b1635123b4a53fbe53f3a7604b90c2e09af3dae7ec839c71426273bfdb09a6f20799a187e813f7a56cc511a2fbcb73c1c91269a34080fa32bd65c683ceb4a9ff18be2d4756c977a086e2cef4a502b0e5b0112c00b43f4385e15a8eb7ab99d55ac81a27607831149054fac38e1a86fa57de73d58bd1dd579188ff4a031b79c9af02a76819268d6015a3bb6b142e97512a8e5c8be5541d3a08a6cbf22d150ebc753eba63df3c8ac8854304fa7cd24ee3eca56fbb1d980962330d30553fe4fff0ccccd14cf3f901d0403d2e5acc5ea84d22e3f57bbdcb5b6fb20ce3dccb4476d2f924a44a31deb9220fcb6acc3d1e0f34f78add2c4b14533d1f109e1e7910d8ec325b4bf0e3b9cbed2ba918608fc08255f8e5e40bb6e1bd8de73d81ffdd72ed22a3568d3a828ada82c31fbd57763db99dbe280dc8819da21628638ca478a1a02fde4fef9e492ae0967911c5f02c4454a2cfd28c3f0937e8a82a3550906b9efcff79aad2583e5000e9cd3998477db91d295bfb3777c30fa3b47fd3c9294404dd1a03b9f2766cc1284ab30fa7ca2430a54120a7d346fc4103656b7e2b933c2a3c221140c6d2df501e090b75fafb52a328455d19a5bc0dd7774876c3e6f301d9f8b0e36abfbf73f2e7fa08df6d2f87b11676e63f10e90d64d7102e3bc4aeded34875857ebfe6d4d482925d1984925182e6d8510bb3df7d6dabbb5a1a7d5cb77a4ad4c2f5095fcb41eeddb8c9ea491e747394baed1cbd06baf1a2357f41d6d0e0ded0c578a6123733deabdcbc6edec217785f6ba598ee08b7cd422314296ca59a825c119f80834caf1d4e63e8d5c8accd70faee45645d4421ecd5331c12d61c83d2b3dd6ebccba13aa174f406e999f78c1128a4b4255a8c33bc3a95fb90c28258d15093596047d1e367ebabc61b81e78b6e65e40b1105fc71806cbf721f80a4101a484e193ac33625b37d697b4f377cb1c2ce4a112b0c789ad251dd9cc7dc1b179428ab6e47730c1679abd56e0dab686af0cedddca5af83ad65a6d52b27c2670923f9d592312061a783f95fc4c6607bd3c11fae0dca106893d1e874d7bc2cbb75044f15b098d06eec0f02dfaa5669c8c7a51571838da1404bb84f2655c1036060020a77297bc428dad1b7664a8c56e4cc9462ccd46cf0f0f225b67dab39e233c53b2c1091fb3398a1fb8cdc554575f71c8a62e9b57a9797a93b4ba4b56f521ff9db424a3e6db434a47084745c7878dcb6db58c7999672e140244c93aa62c2b1b1ebaf5758ab702ee1d51729205adcbca28e73fb1e94cbd550d591d3aecbb24e21b1050e7875576d4dae93b4a6de3c1e8b4c973a2fa6a08304784e96db966662c5198696fef33b8c92d6108ed3d4a0ccaab0be3c526590e83812faf649aaea99745918b6a81196348c4e5665d46dc77515ee2d424a82df87e322f1e12b2b4860ff181cee778b918c7310695248e795345a51e7d6f60b03fe4c0e119bfed06d8ceecd396ee4e33e4d91a6a7374daade338874c59f722f7cd267a770e9b84b78f18548fc308b348930c97c70e1bcf3aa6dacc39f586903337060803d78bcf976c5605beade662dda21127420992ab2f93792a74039f5af163ceba13bb116e08afd6b35b4988aca1bf5bfa36697d6e8d1b36bfaffdb464497d97b8459aa8f2a14aca8840d467b0754e3e679ba8a377b2ee79d5044d70c64110ed1c3b233599af28714a77d245492000f6a96f4782a70f496665694e06a3f12eaf60c211ebd66d0cb20446a77ff89e9cae06ac58fc156beb96f59820718883727424a6c281ac94b1c9db690341c09e078ff913dce03f76d7607970361283baf08c862a223792d7f00aad7ccff4fbc3adb83baa4c7f16d39f3e6f61c061466ca1bec9a310671f9c9185391bfbfcd99b5ba68ddf1420f277298bcee8e032401fbe5a961de40e6e12357d916fc363ceb88877c072cfcea3d6945c5d169f44038fc9a462d5976fbc800eb814bfdba50988b0b9ca3157bdb792190673202de0ae87709682ebad33c4680c3dc63982691890c0e019f26796c4c2b73b59fc57b04b8ba197baaac1baaa1b249c82cef021e9789f3cc86e0dc13164ee73f525ca644a10d8f791c0798ea8810d01faf71b72b1ec08db069b2e4774595f44d8a5febadd7f1cf64962e588ed2050cd6ac11f4ff8d4ae86cdd4566a7527a1b2ced32d50915af3da99501501ecdea45d87345e26ff9162ca30863aab42e4374817f375b627c59ba0912982314880d143826aaa5dcd4f9feada71c00dea79485980062593c52f20922c2a2c4a404e165195c58b391a66c95857a5b3c6795d299dd0d8b2003275841bf87f286ee3383eec25c1c8db4c6c1e23aab85e56e66c2f4a30c78c39f91d94a31c9daf51a0310337a2bbd00df9b6e25e01671f51ef2730ac4977b7041c9b82c2259446d2d58686653a04f7f4146352a55d3fa702329e5f0e52960d1d36d4cbf23263d84de62a8b1bc0d4f4a0178d711e922fc5a6a3fde1e74ae91b56f3903d424eea9b9c5833e1c4667a0a224e51a336659004174fa632f382fef57f6192fe078404fe6bf52856c28d058f5b4294e02a051a8ad252012e6032f728f0302064a226ca4d9b792be10e483a58286aed6391463460f20091a3644998e6b4d5c281da37cfac3e85cbe885b5a0858d6135775eb827405395763ff51dea82cf8ce89df145d8c376d23378895dabc0b7ff709f95eb473174f8345092f6834d7e872177c008723ffc5632dfe6e0ce0f724e9276d4c8433106a7522ff19dbc7de31d66e10bd9a7111de3194a52cbb6a6b93a610281ff86f6b7370fe00bf7c2558dbf55e520c48e55633d18c3955f7f05c465a3f2167e309fbae75f38194a5f217b2736dcc918f362d5bf8f4ffa234ee3f8b990764ee896f965899ecaaa2497c507402ee50c46814e3da51cc0e87132ff6cfd33bd7ae6fcbedcbfe282ab139f3bd71ca20aeec1ff45678773ef090b7cce4127f35f2d464c75c44ce607fcc8b1882149197380de0a91c39483a00a4c64dea23960a5e5613fe9e4bfe4d633da7cbe1857c529434ed404493b8d6a4f3a12acd86d6556ca3478a581856d6bde11140ff2c77aec8fe53b9d94b98d2d0fc55f4604c18860bdea036861f53a36f04b50c227e5867c3c1ef007f23388c3cb3312b9aab8153bfb79cbf77d027e9b79caf66027ba4ff81958cfe344e387d28798e0d1daa1878173c1abb3b75215cc1107bb8535f570fa58f97e6a0b34788d86194c4d11031997d62975c864a0a2fb18d7d5636e0b92915ab97c8c994ed5abd0868c94c3ce88e65e710bd508148b3deb046b42fd006539b00461329b9700e9b98c728b76fd1ec58936d26280fd4ba994e1f8b0586ebe092507fe8b0a2e8b6ed315a66b6c337fac8739e6a7e3a52f3eec5f128c391d5be7522051489b75721bfd4b97a420004c0b7576fc0fd03c7f0a01bb15b410ba5ed8770cf3acb8186b7fb0534a305ce7b89d37d6f5c879a855c9a8042fd9e8a8e087bfd0d272c6cb5e0f215bc463b8879679046cbf863557def91ea066e4f2b034233d9211054de9f6bfd503ed3f488c48bf6307027e45b3709b28201b0f0642a4febecc9e00e0fa60627e188b484cf3bbb4a3554aadbfe66115407ec785a1667c91f14fe06e8450ba7300beffa87d7414891bff5abda2c0e6ea32dfb9b628a341f8995ab9d67238674eba46d63cce6b413f915f76e5e501ad9c4f5a0f50776e485f4d5e848c7b9ffb71f263b6f1aa51e6b623356cf254f8baa14799d8bf262cf45f59c5f8296841002898671c7fbc628e00da8a1ff51179a7768952541db06f093eedb2bcf523e4a999258ef3ca522d419abba42fe9413b38bfb0376f0f2b298ce9b8d2d25d1e1e3e088bfe5738e14badbd5adcfafa17ac04dcab5c6288ef52b42f3d43babd198294da5c2e89a4c72e9f8b3402359f4dab9fa2c6b70278d8299b213e5a72e34c52be7abb9360955faa535e2e94712cd7fc941b437e6dd22f492811aad1fd710ca7fb504af4dbcd2dd369ccd4eaecc8df84ce52eef60b00ed02b078844271b47b2bd6e4d6954fa12cd54dead66e4eefc3c39c2dd9c67e139f9d1040dda4f0aed3f35cd9ae5efa8b14c778671c6d8b6c9c5fef7cce7cb81815b551aef1925f7d016d2017f6bff9de2e08839c3eead6caaa34d26896bff67a851006a25754e014b99283c4cccdbf5268ceb34504d6b4557e684ec1b31a61a90c204db2eef70fdc6789cc2774f5a4e40b8290c4df7332d3bd4ec1489eaeed520db4dd3bb9016ef8ee07c7264443531fcf020dfc51b36c2593ce6ef9d19dd9e6a919963ea6a2c5de4bbb38f46ef3a565f9ed3d90963e280cba028769b2a180c5f0faf5f23060f8154d8470ef939b452d60f9cd1561eb696fccc417e4ea7094b6a3074590ede5076befaf406202de342b5716a8a4f062de1aa6f8e549605a30cbdae58253a0c585af157028a14a16549daab00751f7ec0099fcc5c9fe4d8b9116f8e43e7d37f78364c6ca583b94eb54ace6cdc12287ce10f28d61c436163077324e44029c16f081eee9e605a330ee814e069e21783f6c6a99eb0265c1acb6ed36bf3168ad7e61566ba1f2e34bc69514d4c40dfb02d5c7bb7f990d4e2c582e718b5324c3cc3d710fdb6946d9879040f39d6f181bfce72b2f3031cde78003c9722279cacc911b2055437fb13c274e083b680c28c2121741c5114a3278ebd0956f8ef6875a2bb104fdc738c51609f954617ced57718bde507b35c1222fee1e3dd6709453eaccececc1a800f5451312e0ed88f3a08643dc5d54d501d281c8872da446094880c44e3d0e4b8e8f4b401282365d93bef49920ce11d8a35bcaec9749a0587896baa6b33b3415323d1420e20e7bbee7ea3130c091dcfd03260f20cee72ab60e3930caae8a82cd50b2b11d9158f65d1a37135d1a85dcc437d7257ab16d9811b68015ad688df021e95f4393c076106a1cd436db209623ea3d7d5b66b02f91a1c993afeee535a5d0ba0db8a4a35e22d2cb95bdbf0850f5bee4a10555092557250290b44c1490f2e0835ca75a69714f2c6ef1a8b5be4797a67bf5ef9670cbaa92c70c62415ee7818900772ad7e0fae9352a184912162c993076359745e76e4f2b182f750441d279a19f73308fcdca9889b2f5c74f03b9c93320e8a0b1deec55230ac9c5f5b2b7730acea09f2b220c60ee80f8ed274df2d83af83017dbc8d99c3b5570a43be1ffc563975e5c4445eb7c07cfccac4aa1ee8ba7ae291c8c08ed2247e14ec98baaf91b3733bc02a9227de45c687feee925f4ca2ca9bc8f3b48578627d06140251c4879fd80df43557ee6edaa466540a693a69b18d141d8466956e78a5bcafa3ed626eb8ac480b05cad0dfa19c1516fb9adea13a9e0f4cfd907cdda7bf3d09b8a0ebc642981bad15375bf30b4486308ff7b31c7af19e7567277f73ed63ac4a0a27177fdf44b2e92ef0a2d19f64e191a4a50b96baf46f1d524fb7bf7ff2a93e2854936219347a6fe5abb8231f9ed24d4c7397dfbb70a013cb0038d7fac38beccd1b6b570d13eb8b5cbff1829a6c31912b8ea7de6f9b8cd4d7ef23f011087aca303d98584dc823658a7a33bdeaaf30b7f8e18887f39d9c00dffa2608fb0f221b362e4db41bb915fae75e174b3450d6928330deb5a066c69a56e903e5f888bef989d4d5ac54495b2b4950a3bd9e083342d7741baa33e4d267e3cbe91c2e05b9a1a18d5947fa030eda4215f2cbf368df8500ed9e16ec5dc0ceaaab8bdc82e9a783081430f7e33649326021c083a71155bbedfc1bd891c7691b0701d6c43abe551526536f16bd35e0aecb9f5c4fd4ffc7640ae4e85ca7406c9d07012cf419fae743ad9e977e24276d46254a7c3a09957c0cd29fedcc9c8690662d681ceccc82cd840ec5301fd41809f64bb11713069c5c61f0407ff84ce2f7fd676ea4b0bf4c5a2262fcedb3d65b6b7416c660180d879c21b10dad144ebb81096aebb1a69dae6a512b35a13a83f90d36d81fbb0383e72a5d77c45a89fcdff81afb181bc81e190861a23d6361a3a5d01abeb759713d235033366d49c246b63f437fede7461a384b7757abf86debdbf496457178583597437348710f4adba4ef7510a8a59128b49feb617bfded1fa260e664389813bcb67db0a526b549fcc77099deb5dd69a90436f4164981b55441fdb082318684cb930862df0a3e41ffcfa286ca9346fe38d5ad11bbf386e005f1e5e893f35e2e2906d8a008b6237ea28703c88730b508798cf36a4a649c051591c4739da168e3f318cb74cfc685f436993ed564605013aa3597d4bb722f8c9e35fa9368cd050b4b9c7c6cd3762daa7c1059a0dedddedf888721e347e127fe0b38295e2728d386858c1cfe49b367d6cb4c3b0e2ece4efc70d3b77b058fcce709e9c86bafea8a6e03f9d64788c25254b5f7672c414d2857ab3969771bea62640cf80140bf494c110a7aee91dd4ba8ebfdcc61fb2c39cbbc4fcf49441c5a8bbf83c2eca7b4ff1d5d0ae398eb98d51b52effbfe45e82f374be95931ec0e1d3aa49fd3d868ebc17c630dac33fb8582819c71d4483eeaae1c1da7adf1d0adfdb8d740c2f26718130ad51e5b1e7964540220170877ad41deaf7cede329218677d19459ccdee0fd92eee35c469bbca9077e04bb788827d92b029266352537d2b123acbb79ebd2aeb2e95e7ced7e1a62988a9d1eccd97c60c1778180e0eecb5a54acf7cdac83435e628c124432e2cc9d1dbce754b3141d0d874476ee876446b7152671cba7589df2db15a006ca08ebdee62e4062b644fdd28388f27cdad9c4102aafbc9e16fd330c257c723f6edcc5d7940c04a405f606677aa0faa3e8279c09186fed98e1712715b9ae77cc27a31325a1191ae90d83169f5e26c084a660c614a89d42e12ff561e2b057a5a8d821ea2693cdde7fe704f6f866955a60d0eea0c1a53e5c7bbb738a202331f638f30391c62541b3402130b47fbfdbc66d2524516335956aaf0a1234ef226fb5aa489c96e9a634babe3b878e12bbf6b82a2414815f85a9ae889c8d4bc1e608c371d0a908cd8805b6694b8376d5e1c55c9b9edb79d1d39c12f1bfa4ce0f60e32b4ccf53426e57d23dd19b76a7a637fd94208e4461f924da18a269a04bb87c2a18195feb5f60008ef379a201062ca8522cc7f210be071aec2f177540aec6f935ce3fbb00323946e9e2d00ac9471510f478a34621056dd26c77712f5918bbbc1b5e61a61e69fc9246bbf0842aa3de6b79656d6726799c8508e7131729dc35b38088f77f39bead3fa6272fb2d2bbfe095adddb8d871bf4baa8862fa310fb2e73953993aa33f9daa86b915f38f97dc2c720d651f754b3b5feb32c6d7df1ed4698c2ce940049f83c615ac996bb2aae201cea44fd37211f207f291f2f4e7f46cfac896fca9676baee45143c8dd2c3886b5e90f12c121a40f82e73e400a442d288484a7be57201a6ceee36c9bca8832c41c9d7544a401ba118d5f6fba25ba6b4cc540ca6f8b0ae526c58dd2bf7878cbdc68f58565b4879b451a470937754f62dc9740bc9254578b92b0397e1fabbfca74f23ab1826177b6952146d3e91455f66e4e9897682e1e930ae236848a2f3b19963b17b8d64a5f4edaf30ffc842b8499fbe7bf2e6c670b720d63ed7031dd3ecf1385ba2f1e9003570e5dd3267d24294accdede2a35bb2f7d91728f085d8cf49c92492f0156be8382c153ab7481d6efde21ca0cd37fee73372bfd8b2601ce7ca19e7bb3e681cccf194b0f6a6c673f90e92925d7ad5e50333fc8c97d9ce3a29ce16478dfa04c6426f49ff4bc141366c4edc93a548e9f17c9907d38dac0a9b9c88d095c0002e7cdc9d6b2225887849a5c0a3baa29964d374a3ad979a751ef058ac5382bbad8d74d36197a1b7229c2e54c6520f3ce37de29c301ae21cba5dfba917154384e474f5dcd80c31ecf251a09db1510b4818a9d79ad2f663d7854a3aeec03bffcf86a02e8f5140a3d925bd084dba170907938c39f8b6354c931de9532fc9941b62a3cfbde99c8f0856638092760a4640bc621be23c737d319ed7004df5c071f3f1be3e0210ae8bec32db37a2099b41624852aa39931c462cbeeb1d86406705d00caa0acedda8bce70793a966df55f4fba5f3a3e0939205c0f3a024d9c1d44898f1ad8c014505846f04ac7fda44f9a3abce5ed6d2132ae2c48e607f9f6da9be94b93ca6fe7d813f52faf3be0eb5488df621ce755ca1c7d56a2dc9de5b6ee99b7cde6fd05f2f406255e1bfde669c3837da0d0c5cbbc740b4addd6c0125a619aacccdc428777781af83b2f6b9fccc1207dde31aa45335186a71e527eb6c2765ef5d380e134198e769966b0d27e472e8b21c117b2a1aacb71537c4218849ed2a4154845c5c5c94b062acfa19d675ff62af8979384e1a9ab5af1634ac4a528f282cf815bba76d64f463a06ac82f12cd8ba8382161f60fcccf02fd3c349d1b94c4bb006762818ef80c4078d8a819ad7b4664d56cd1adddbc7d6d37b700bdce25d4e83edb57c55d54530f260544122431e74fee49a080a68429a3392ccd8271c4acd5fb0f8da6d08c5ccf8e4f91282aff8dde7246b7c30c56cc5d360a48238217379bffa728614c7b2702a5af034f66d82ae53f8a4e549d514b51c1671109617ed1ca758c18a33fa53c2f800387b10b343c317fce1453e2cd4ed4991e7c9297f1fb734d6e86064bf0f83eb45ace7f85948da973d09b6c94117f1a7d55eae075106084636fcfd1652821a96f95a1e3a5935333d5eb2989fa56a5babf9c9999fc5f2c31430bed473240b33a69768dfec78a7378e5147ea770a771362f1dbcd64badeeff4ca230bec1808d5df546c4e919aa64eef94f7bd948fe529dea278d197406a0f93ae6e18ffafb31c0ec9f01161bf85015e54734ae2833a150a9c562c215078133311b948ca38185aea45c27ebb523c4fb882f39e04f3b793d4286c77445ce9cb9591923cbb659f6c776858fc43cb8d60dc0ba5b02bdaeea7fa133128ea3176493aaabca95b3c7c0590139284ab0de9a594109043a8c8e94a48d71d4eeb9cca363a09a3042337b642b41304137cbb971e246c4c875a3d6f76e60429b7f51ae548c2cab855edda7847278d5e9da1b62d37b00c85379114114f2c77333acf5e946acbb84b5181712616804367acceaf578cee14de0fa71f4b630389109a3566bb7f3cb132334410481e55d53d521d67986a44d2c87cd91302512ed2ce3c73b3d2376dc8c4124c0cccddf1e32657550977bc5184b24c46f20ecad39bbc41571be1aa91103adc71a3731bdc9ad7447b0e0edd30afe93c83ccc46cb656aa914c6b01d710a5f660ccb201e48b1c1ea0ac04b47be29d57dcac62c3f850bdae68e7c3a857591ecfe8f0dac7bb3bef157a0fd2747ef6824322f36c8d249089df7ce9d2b3407c03571a36c66bcd440d0f6644688464321a6861cd3b22a28d26bec89681d81d8a1bb62a1335eff7ab689c81c61648c86f6c4d41acea08e412be9e1f79676bfc408ff7f402ed098e76cb31c8dcad2079a2b1124c7fc62cf6b76284342f67f907a7fce7184afef64a7e9f5898377bdbaf03125cf3c210971f72c31f35578ce7ff7162b22abf4fe4dd3b6f13efc9b1327d3924da2d06a4d0f4888d1a19065a1c3858d9f90320c9c0975a75e28c1c413fbb282f6a495065a5adb7ff19fb10b98f5f5e2785771b6018211eddf397ead64ea517fac22cf0aaccf426620eb1e4ab2994ae99e520c7a17b5f73c42d09f71902d9ef106e58554935501ac83e5e302db2ad92bcab89c749661ebdec8a63822a50aba43b61282b12f2b99a40b63c03ac3a00c594ac182e8f6fe9369a1cb9b4166d321c1aad72f80f7ffc9377b7dbbac106ca84f756dd619c2872114fbbfdcbc6c4c664b708a36139e6c7571bf1ea4ed1ae3467165b16ba2aa3130b647d8c704bdc9c76734e5b4b6b1c6432de979db6d9aeec6c914314e9b95912b45a122a9d54bcc5c9bdf69543680e033a53728741d40c50da805ca79b2be903b039374cd674fd402554f3579e4cb34e7ccf27d799c1d1eacab5729a8be7f0aba6c8760b15e3c92bb139af0021ecca43ba957c9b0600244d48f541a9cfdcfbdce99496dd01072af8247ae22f8198f228f471b97768966791d293c2c72161956df3fbe305ad8cff6509faac6d1498f0e0db909b556684906559fdc1e5e53aa4c424e6375dc5f1ab37e9e0e5dfd2c1aeb1ab4f979ec9096f0a11ea2b3e60bf2dd1bacfa0d47148c205efda3575235e3576aa036147d0de262fecb1b2d6ee7afbe40314d3a423074d9fa0e2fc5a84f6beddb593ce3e379c86eaca875889f630721a9a818635dceed7ddc82d2b2fa4eba4200231b104c0fe55bc5bf60a485da9d280198ce1a0700d80fb438f16477a66ac87cc80c5df1540ffae75d3bd1867f6b9171538d4c907a63c834440885d849905af43af3159610b70a4c2f5c093805606bef84d0145420eabb87cbfb2fce4c8ef456d18b24d61af9dd9d425329f36b9ff230a2fe9873a88dc38175632fb6bbadec72c519320106d9668fcd87fe0ba6128d08d3ffe293bf499718d85289483b905aab97609324f004fed7f187e626f8da05eb97ab20824d920aa6eaeb7f40af1d3cce5cb2b802bded4c9ba830b4737cd279fab1706d36a0efe8b12cb13cade79df68d919bb8f9155df216046b9bc9ed772a15bf535dfd06fb11e438772611ac09378b2b79b98836450dee72764112e1f6af536322efa3230332747512922f03c13afe0aa5a3f220b397b3038b9b5655ad21e60cf71633e447d43a61f4decbcf5833562c55b9eb27aa0a2d9ab649f9687d0cadc53d60ec0628e0c5c033139f0051513630fea2d3b67d73fbb5001266f016e1927fa9e5903076bdd64f12fe2470088a6dcb441eea077a5386598841caf50856aa00ae718f7f37e24a181498bd3826b78d52974c12dec48ba67111bb9c4290cbb2c79059b98d5945e170cac60442eab52c47546a1b47bd90adbae44c65de1e8608074d5b70d2ed43709002e2800717aa5c27a08dc70349dcff831dc16692a8d6a2fb7379d537e996787d5e9974a060cad6d96489ff8fa675885a2538e8f7b10c9b631329c370937aeab52d137946dc23654b1c44644a20d4856cbb3c4a0f505317b34a493403ecdd69d835690826b6f0e6936e7684162b0cd525deb88a16021644895e8f452090d76b219ec1bac2308e5b629a5d15ec596e1eecc1d61bb29dd40cc582e1f0d3f78f9b37886a499dc237ed7d9b77e78c3c3fe757722a84f7e7efad908b0f645fc23c25ca7189a62d4d0932a125a94223f6862fc6340e08b78ff15da94875650a9db4b676c7390e32f1320b00799fb6098a29bc859165f4a220e06e77039503c4402400d57c95dc0f01cc23943a9fe31ef93bf6bc50745e1b2f79f2a668f7c13d4f7a5eaf452875c9e2eb8363b6ec48bfc14bcb8b1fe594138189e18e48387e48dadaacc878ca1ad8aca4f89dd10a92b1aa7afa007c12a21a7f07fe95ce5fdc0536d9bc3d74d66b6d98e6dc053948f7c36b8fc3fb38748ddf09f64eb315fdc147107be9766b3011b9dedc68d46185046ff11bd237ce27d0d62185adbd4df8dff9443a010ae6119b52b4271362b1468cb32b1289ec8cdddc69581ee3892d45c679043919678da084516b267b1e7738e22907cfb80e1049cdb146f6f7794dc0aa11e927974b8c43adcc15405573825a73804d963974d15ce1827a40d30774a30cf1aad52f25fe76a0d30626a37118baf13fd97643fda8896a39f2993258520cb239f2977a1dc67dfaee39840f277b9486dd31fdb4b9f7f8c0be9c635193d9e2d40ef6202aceb28a480c95140baca16ee5c7c1f6558a4c3682c1c9aa1cf17adac7edfe3b66a87f310a1731a932faac823bd61ef6487b8c7c32c62c1606ca229b0c6382aa1ae69b8979720afdcb67e1f858de3829eda97d48d3c0a0f541aa8161c762a86ff9c4b0c553d92e620310af03f25a161602ae92cf6ae314e0dbcfe9464fd4bec2d3c0a9481815edb8896ee0aa713827adce3cd3490c9373bb25f35a16c86a0dfd025730fd45839768b57898bc6471f063871bdbb8c5110d86db69ba3d7925f58625fd04e8914025c08ed120fd15fb65f08cbb426651c8900db95ef01526deaca3da216cd1bd029a20bd925acc974a983a5b6a22bad7de3bdf1660928691fdb35babd8505d891c10d2f777702ff98bb1e185243586597feaabf5d79eb85ef289f1556302da978fc7de0144d0f5e60151ddfd3e0a5fc77477ce5f805627d24c7654827eb4059d8e832150a182dfeeab50f2ab155a052419ee7300651e7b55293dbd84fb903b1abd0be6ba49d64c2ac8fe89e9e0c89d85eaf7f368d39552911922c6089b5e4618371a14dab7c2fe4e7f1ffbeb10d21344d766860f3207b8270e099c6386c51d769017e4e77391b8d7c245a8099e0719c8fc24b5e84a5b51ae6cdde82fd0ca93816366307fdcaf8059371814a55faf3d1a79ccabf831691b0071faac967309c869ec15c2a1eea812a0e09dee0c66754dc0f5ba3209c23f79a60d787c11cb45794daa3d6d65e043dd727777e13cb9abfbf6fb6edbfed2430a0c211b89495d5dd3ff715789aef414f010b87a49bdf11c22a627a6eaef33da0003f41589575df3f71b897eb0174a944aff8d64cb7e840eb8fc360d99a0f0957d3651f10819537bdf1fb50735a0014486ac9798a6fcfaab097fdaed7271be5cc546e16b3be52dcbbfa454a1ebff5333813837086887d9768b44f20478927ddf26b4649728469d885443cd6af9b61b4df8e29d6c00da1092e2782253b60fc42a3405adb4a7e3e35f49b6a07aa290a35068b80fb23a9a47312b72a3916497b8d901a3eb7bed007f8704c1193dcfa212de416ccaa232a0454a9d81254cf41b4e820a19f3d8c60f934b607d4592e115de1d7f408fc0ca3fb7819c438cdfc95bce5651b45fcde945e3926bfb8c0f0442473585990ff096e110aca92a4b454359cbb269cafbb6c9292158b3e1eaf75395ba84c5df90a32d48e59dd0c9d3b94affdd6bddeae02d025072bfa7039aff3afe0f69d22f2af1d196fcc90861c4dc1ba4ab4d3355dbe6ed0c976f50189a48804f23a64371ca4ef2a2d3dcb2d9154641c3d321fd0950c37c833faa4e432d3254d0739bae50cbbb304df536cf35c954f0e2e7ec86d00c5d5a4b87cfd136d6df2440720f853dbcd7713f31952645145f5ed616b1e0d2b61a7e7704d6d1c049dc409a848886d5c656c15037d322451157bd75fb391dc74e8bb007d911848eded830bb00f96b61084a9fd0ae38984232debe412064e08d4ccc5d62c16ebff494034f19084b689964412c0029be91bc8b338cfea881aafa1dda5e0a1934ee17466be6be41902e6882291408080e1c74102ab0113d8c48fbdcc4ad7d5d19ab00cbc5ed52034e19f8223b7daa821ed64b84552d7085d76831f65ea520e582f2da51c10eb47171181f211ee702f70a971e1acc06c8d9f7d4ea7218cb453000262d8af9e5a15218e4ba0fc1c84f0296878f54e506afb64ac897c553e637a7eae46e588388c6fad4181ef31519b86ad2e97636ab9fe610cdb7cc2bbc5007bccc2a68739c299ef6d9493c7dc66e4a4ba41f26a3cf9d90acab574a0a1c8a4870b4bd4b63fe117271795ec12c8bbc71c966e832f476829e0c1505abfe6212c4d3418ee2b94dbf2bad4b0d5f9f4aa1404ffcd198db203f6ced05c66c0d6817940fab921ed20ecbc7bf0591b8074ecfc6714cd93818b81d3a57893cc4b09a81cd63a61f493b480bccf0ffcd4a0a165bced33ea3bf5c8415ff34c00682093c94ea14566a26a6b8cd414ee69fc547b0b4e5ee87859e569916a17a3be74dccde84f89550bf7696a0035196106c75bfcea3d51e6b41e3a8ee1ecaca5908d38e8f503596a1414d213f2ee977ec6fc564e0f27174fa32d9e1235dfcddcdb0f0b351662521553ff04129caeee43a257127738436d6de2a0b336a247b32088f3601b1a7335e3042f4e5c5e2606d9d341691a1285d0de4b6b16463199a88b93001bb5ac4941ae72a2f663138e29f31a4d3f16d8348c261dc86db69248d7c157a626254f519350ebf838d7a053184ec6e919159e26f0578bb8f9c03a5b6a58acb8f6c5ce5f498e6c54a1c08ed83b15c7fcb448c72084dfb9545137015b84f4fb19ff933667022e64633d79982e1d2ffa3a8a25e1a058b928e8e5ce1e6d648c7f1cd2867dfcd164e4e91f6fc530a7b58b5b63ccc4a9efdfeb3f95d938f0c7afa5af8e974e58d51bfb534bde913080ba9b35b383f134e26ae9b51a36c6d3f86fd2aba56553767b387b350f4deb155af8d24a6ad917b70ea78b5a454255a43e056881886caefdd78cfb993a6c03cef39982da4af283d4908c9d33a3cf607ab06c4d5a4c28f06670091f5cb02594ac91e48d6f8a7bcfd16dace23083708a7b9d3b960ba9a49811b88d4e81153635cfc2eef876ee5e33444665dad5dfbc157ae5498bbb0a64c0ef68233b84a10fe19712efbfefcab095e9f9c86b1a092b5500ed5342caefc753ae322ece6c884f36fb0568ee7e6b2b77b9acc4c2e17d3f005b7457c15fc9f459d1bccd8f787a55ab610ad05428e4f57188ad141688b045fc7a7f2256a0285385e0cbb2d6f5051f04f6bee441ad655436f059e9d549905b839d469005efaa9e409f1640fb0b7b31d8c9213129c787434a28cbb146b3e5f5e9f8dd2b4ffc67ff7970cd27abe2706c200703cc19ce89ba439303265b5f856d111c6c2d353c1d64c8eefa5b5f6adee23a601449b2e1d46050956ce822c32f9a23a6dee09cc4c83ea1823e39c14388dfbe35499c51ad022775e62fa1137a4826a96497b74465781cf5ca83e0bb1f4d655c8376123875d5c69b60d96ab5231d47906068ac51fd5a227db96c65c3e64b179acd05d991475cd636cfc3a2789b8c7b4ae4fb6cfd0120371d5b269a4780610ddf66c59c794d8a86d1ecc760dfae5657809d6a221247c6b2cf813f99443017a07b650ed7ff2803b39537ef794b52502ff38a439ff6fa6daaeaf33f4b8c42f5fe4150289891bae104fcb8eb96097de0ceac014d47ef28708348922235bc903e88674daa6b5fa63021dfcee205d4aaa39a6640c5b80cbbf88e2528198d8ee05aab50e271d78537e0bd5af82cff71b4342aa7e2a9d4070329eac13b15ba237bbb3a082d32fcb702673ed1133e98123f5144c743c9cc9538baaf6246b962767141e01e02748a116a2cb975a3fadffeb426c6bfda04241b9363a3d029f28244fc9d4264f3e63f80cbec1cb6edc5bf95de32e636a322fd8d904470b885c524b8b0bf6059b7aa72435eb1bf4c67006a5b0c404204dc2eb03f90a7d01dee7178f9356b7fd4a46ff340776e02f49307a04a771b7261d6308804208e8055b421f275a2ea189bc3e03559917a0c1f92c03a467ccdb1a4892a18e33fccafc9f140e0309ed85f10a3d922b0f266cbf0f8a8fe8f9bc0f944cdfdee79d6b32aa047630ee75ade19f31d73b3cd222248d755d1657c173f89708d5c89ca76dc3ffdb7545ddd85c9e6546a22c150967ff93f0583a1a7ff01bb9d15d5ad1cadeae67f5d97c4efc0da722da6fb3757d9f0c4ed76ed5da25499dccfd3c36e12e0a90553bac6eec2aa215f166f969bd4306c29e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Acwing</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Acwing</tag>
      </tags>
  </entry>
  <entry>
    <title>UcoreLab0</title>
    <url>/posts/34866/</url>
    <content><![CDATA[<h1 id="Ucore"><a href="#Ucore" class="headerlink" title="Ucore"></a>Ucore</h1><h2 id="Lab0-实验准备"><a href="#Lab0-实验准备" class="headerlink" title="Lab0 实验准备"></a>Lab0 实验准备</h2><h3 id="实验环境设置"><a href="#实验环境设置" class="headerlink" title="实验环境设置"></a>实验环境设置</h3><h4 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h4><ol>
<li>在屏幕上输出字符：echo</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "hello world"</span><br></pre></td></tr></table></figure>
<ol>
<li>显示文件内容：cat、less、more</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>注：在本文中所有带&lt;&gt;符号的参数都无需加""，直接加对应的符号</code></p>
<span id="more"></span>
<p>less 和 more显示比较大的文本文件内容</p>
<ol>
<li>复制文件：cp</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp &lt;filename.txt&gt; &lt;filename_copy.txt&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>移动文件：mv</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv &lt;filename.txt&gt; &lt;filename_new.txt&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>建立一个空文本文件：touch</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch demo.txt</span><br></pre></td></tr></table></figure>
<ol>
<li>删除文件：rm</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf # -r是递归删除 -f是强制删除</span><br><span class="line">rm -i &lt;filename.txt&gt; # 系统在执行删除操作之前输出一条确认提示</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 特别注意 如果每次都忘记输入i的话 可以让rm的 -i变成默认参数</span></span><br><span class="line">alias rm = 'rm -i'</span><br></pre></td></tr></table></figure>
<ol>
<li>查询文件列表：ls</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -p # 显示某一项的类型 ，可以使文件、文件夹、快捷链接等</span><br><span class="line">ls -a # 列出包括隐藏文件在内的所有文件</span><br></pre></td></tr></table></figure>
<ol>
<li>查询当前进程：ps</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将会列出系统当前运行的所有进程</span></span><br><span class="line">ps -a # 列出系统当前运行的所有进程，包括其他用户启动的</span><br><span class="line"></span><br><span class="line">[ucore]:~$ ps</span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">21071 pts/1    00:00:00 bash</span><br><span class="line">22378 pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure>
<h4 id="Linux下的一些特性"><a href="#Linux下的一些特性" class="headerlink" title="Linux下的一些特性"></a>Linux下的一些特性</h4><ol>
<li>重定向</li>
</ol>
<p>实现将命令产生的输出流指向一个文件而不是默认的终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls  &gt;  &lt;filename.txt&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">ls命令产生的输出 将会写入filename中，如果该文件不存在的话，将创建该文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果filename文件存在的话，那么将会覆盖原来的文件内容 那如果文件已经存在，但是我们想要将文件写到已有文件内容的最后该怎么办？ 使用  &gt;&gt;</span> </span><br><span class="line">command &gt;&gt; filename </span><br><span class="line">ls &gt;&gt;  &lt;filename.txt&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">另一种重定向方式</span></span><br><span class="line">command &lt; filename</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 讲一个文件的内容作为将要执行的命令的输入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已有文件 file.txt 内容为 1.txt 2.txt 6.txt 5.txt &lt;Ctrl-D&gt;</span></span><br><span class="line">sort &lt; file.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示效果</span></span><br><span class="line">1.txt 2.txt 5.txt 6.txt </span><br></pre></td></tr></table></figure>
<ol>
<li>管道</li>
</ol>
<p>Linux 的 nb之处在于将几个简单的命令组合成复杂的功能，它是如何实现的呢？答案是管道，管道符号为 | </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -i command &lt; myfile | sort &gt; result.text</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令含义</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索myfile中的命令，并将输出分类并写入到分类文件到result.text中</span></span><br><span class="line"></span><br><span class="line">ls -l | less</span><br></pre></td></tr></table></figure>
<ol>
<li>后台进程</li>
</ol>
<p>CLI不是系统的串行接口，可以在执行其他命令时给出系统命令</p>
<p>要启动一个进程到后台，追加一个“&amp;”到命令后面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 60 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 睡眠命令在后台运行 您依然可以与计算机交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 除了不同步启动命令以外 最好将<span class="string">'&amp;'</span> 理解成 <span class="string">';'</span></span></span><br></pre></td></tr></table></figure>
<p>如果现在你有一个命令会占用你非常多时间，我想让这个命令在后台运行<br>只需要在命令运行时按下ctrl+z，他就会停止，然后输入bg使其转入后台，输入fg命令可以使其转回前台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 60</span><br><span class="line">&lt;ctrl-z&gt; # ctrl+z 键</span><br><span class="line">bg</span><br><span class="line">fg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;ctrl-c&gt; 为<span class="built_in">kill</span>一个前台进程</span></span><br></pre></td></tr></table></figure>
<h4 id="需要了解和使用的一些软件"><a href="#需要了解和使用的一些软件" class="headerlink" title="需要了解和使用的一些软件"></a>需要了解和使用的一些软件</h4><ol>
<li>编辑器</li>
</ol>
<ul>
<li><p>gedit </p>
<p>gedit是gnmoe桌面环境下兼容UTF-8的文本编辑器</p>
<p>优点：语法高亮，中文支持很好，简单易用</p>
</li>
<li><p>vim</p>
<p>vim天下第一好吧，unix下的vi的改进版本，功能极为强大，unbutu建议升级到vim最新版本</p>
<p>[1] 了解vim的常用命令即使用，暂时空缺，下次再补</p>
<p>[2] 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=utf-8,chinese</span><br><span class="line">set tabstop=4</span><br><span class="line">set cindent shiftwidth=4</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">autocmd Filetype c set omnifunc=ccomplete#Complete</span><br><span class="line">autocmd Filetype cpp set omnifunc=cppcomplete#Complete</span><br><span class="line">set incsearch</span><br><span class="line">set number</span><br><span class="line">set display=lastline</span><br><span class="line">set ignorecase</span><br><span class="line">syntax on</span><br><span class="line">set nobackup</span><br><span class="line">set ruler</span><br><span class="line">set showcmd</span><br><span class="line">set smartindent</span><br><span class="line">set hlsearch</span><br><span class="line">set cmdheight=1</span><br><span class="line">set laststatus=2</span><br><span class="line">set shortmess=atI</span><br><span class="line">set formatoptions=tcrqn</span><br><span class="line">set autoindent  </span><br></pre></td></tr></table></figure>
<p>将删除配置文件保存到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure>
<p>注：.vimrc默认情况不可见，ls -a，如果~目录下不存在，可以手动创建</p>
</li>
</ul>
<ol>
<li><p>源码阅读工具</p>
<p>understand</p>
<p>商业软件、跨平台</p>
</li>
<li><p>源码比较工具</p>
</li>
</ol>
<ul>
<li><p>diff、meld</p>
<p>diff：用于比较不同目录或不同文件的区别</p>
<p>diff是命令行工具，使用非常简单</p>
<p><code>meld是一个图形GUI程序，非常好用，可以直接比较两个文件夹之间的差异，非常直观</code></p>
</li>
<li><p>patch</p>
<p>patch是打补丁工具 他也是一个命令行工具</p>
</li>
</ul>
<ol>
<li><p>硬件模拟器 </p>
<p>qemu</p>
<p>只需要了解到最简单的<code>make qemu</code>即可</p>
</li>
</ol>
<h3 id="编程开发调试中的基本工具-gcc、gdb、make、makefile"><a href="#编程开发调试中的基本工具-gcc、gdb、make、makefile" class="headerlink" title="编程开发调试中的基本工具 gcc、gdb、make、makefile"></a>编程开发调试中的基本工具 gcc、gdb、make、makefile</h3><ol>
<li><p>gcc的基本用法</p>
<p>安装gcc编译环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>
<p>编译简单的c程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hello.c 文件内容</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	printf("hello,world\n");</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在命令行下</span></span><br><span class="line">gcc -Wall hello.c -o hello</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数解释</span></span><br><span class="line">将hello.c中的代码编译成机器码并存储在可执行文件hello中</span><br><span class="line">机器码的文件名 是通过-o来指定的 这个参数通常作为最后一个参数</span><br><span class="line">如果被省略，那么默认输出为a.out</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Wall 参数 为开启编译器几乎所有的常用的警告</span></span><br><span class="line"></span><br><span class="line">./hello # 执行文件 ./指代当前目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>AT&amp;T汇编基本语法</p>
<p>AT&amp;T格式的汇编与Intel格式的汇编有一点差异，主要在以下几个方面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 寄存器命名原则</span></span><br><span class="line">        AT&amp;T: %eax                      Intel: eax</span><br><span class="line"><span class="meta">#</span><span class="bash"> 源/目的操作数顺序</span> </span><br><span class="line">        AT&amp;T: movl %eax, %ebx           Intel: mov ebx, eax</span><br><span class="line"><span class="meta">#</span><span class="bash"> 常数/立即数的格式</span>　</span><br><span class="line">        AT&amp;T: movl $_value, %ebx        Intel: mov eax, _value</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把value的地址放入eax寄存器</span></span><br><span class="line">        AT&amp;T: movl $0xd00d, %ebx        Intel: mov ebx, 0xd00d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作数长度标识</span> </span><br><span class="line">        AT&amp;T: movw %ax, %bx             Intel: mov bx, ax</span><br><span class="line"><span class="meta">#</span><span class="bash"> 寻址方式</span> </span><br><span class="line">        AT&amp;T:   immed32(basepointer, indexpointer, indexscale)</span><br><span class="line">        Intel:  [basepointer + indexpointer × indexscale + imm32)</span><br></pre></td></tr></table></figure>
<p>如果操作系统处于保护模式下，使用的是32位的线性地址，在计算地址的时候不用考虑segment:offset的问题</p>
<p>上面的地址应该为：</p>
<p><code>imm322 + basepointer + indexpointer × indexscale</code></p>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接寻址</span></span><br><span class="line">		AT&amp;T: foo                      Intel: [foo]</span><br><span class="line">		foo是一个全局变量，加上$表示地址引用，不加代表值引用</span><br><span class="line">		对于局部变量，可以使用堆栈指针引用</span><br><span class="line"><span class="meta">#</span><span class="bash"> 寄存器间接寻址</span></span><br><span class="line">		AT&amp;T: (%eax)                    Intel: [eax]</span><br><span class="line"><span class="meta">		</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 变址寻址</span></span><br><span class="line">		AT&amp;T: _variabl(%eax)           Intel: [eax + _variable]</span><br><span class="line">		AT&amp;T: _array( ,%eax, 4)        Intel: [eax × 4 + _array]</span><br><span class="line">		AT&amp;T: _array(%ebx, %eax,8)     Intel: [ebx + eax × 8 + _array]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>GCC基本内联汇编</p>
<p>GCC提供了两种内联汇编语句</p>
<ul>
<li><p>基本内联汇编语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asm("statement")</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">例如</span></span><br><span class="line"></span><br><span class="line">asm("nop");</span><br><span class="line">asm("cli");</span><br></pre></td></tr></table></figure>
<p>“asm”和”<em>asm</em>“的含义是完全一样的。如果有多行汇编，每一行都要加上”\n\t”</p>
<p>这样可以让gcc把内联汇编代码翻译成一般的汇编代码时能够保证换行和留有一定的空格（增加了可读性）。对于基本的asm语句，GCC编译出来的代码就是双引号里的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asm("pushl %eax\n\t"</span><br><span class="line">	"movl $0,%eax\n\t"</span><br><span class="line">	"popl %eax"</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>而实际gcc在处理汇编是，是要把asm(…)的内容打印到汇编文件中</p>
</li>
<li><p>扩展内联汇编语句</p>
<p>这个太难，用到的时候再看看~，先鸽着</p>
</li>
</ul>
</li>
<li><p>make和makefile</p>
<p>GUN make是一种代码维护工具，在中大型项目中，他将根据程序各个模块的更新情况，自动的维护和生成目标代码</p>
<p>make命令执行时，需要一个Makefile文件，用来告诉make命令需要怎么样的去编译和链接程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 场景模拟</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在我们的project有8个c文件，和3个头文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在需要你写一个makefile来告诉make如何编译和链接这几个文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">规则如下：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	1. 如果这个工程没有被编译过，那么所有的c文件都要编译和链接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   2. 如果这个project的某几个c文件被修改，那么只编译修改过的c文件，并链接目标程序</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   3. 如果这个project的头文件改变了，那么需要编译引用了这几个头文件的c文件，并链接目标程序</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只要makefile写的足够好的情况下，只用一个make命令就可以完成</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>makefile规则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">target... : prerequisites...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>target：目标文件，可以是object file，也可以是可执行文件。甚至可以是一个标签label</p>
<p>prerequisites：要生成那个target所需要的文件或者目标</p>
<p>command：make需要执行的命令（任意的shell命令）</p>
<p>由此可知，target这一个或者多个的目标文件依赖于prerequisites中的文件，其生成规则在command中，如果prerequisites中有一个以上的文件比target文件要新一点，那么command定义的命令就会被执行。这就是makefile的核心规则</p>
</li>
</ul>
</li>
<li><p>gdb的使用（非常重要）</p>
<p>在可以使用gdb调试程序前，必须使用-g或者-ggdb编译选项编译源文件。运行gdb</p>
<p><code>gdb progname</code></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
        <category>Ucore</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Ucore</tag>
      </tags>
  </entry>
</search>
