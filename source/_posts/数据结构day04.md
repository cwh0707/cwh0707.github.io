---
title: 数据结构day04
mathjax: true
tags:
  - 双指针
categories:
  - 数据结构与算法
abbrlink: 50706
date: 2021-12-17 06:55:50
---

## 双指针

### 双指针分类

+ 双指针指向两个序列（例如归并排序）
+ 双指针指向同一个序列（例如快速排序），用以维护一个区间

用途：非常广泛，它的作用非常之强大，可以用于朴素做法在O（n^2）的算法复杂度，下降到O

(n)的级别，对于双指针如何使用呢？首先我们先给出朴素做法，然后从中寻找对应的单调性，如何我们可以让内层循环只需要遍历一次就可以计算出我们想要的答案。

模板：

```c++
for (int i = 0; i < n; i++)
{
	//第1步：判断j的范围 第2步：写判断函数check，观察是否满足某种性质
	while( j < i && check(i, j))
		j ++;
	//根据每道题目的具体逻辑来做
}
```

<!--more-->

---

#### 单区间双指针



题目描述：

给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。



输入格式：

第一行包含整数 n。

第二行包含 n 个整数（均在 0∼1e5 范围内），表示整数序列。



输出格式:

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。



数据范围:

1 ≤ n ≤ 10^5



输入样例：

```
5
1 2 2 3 5
```



输出样例：

```
3
```

##### 分析以及思路

朴素做法（暴力解法）：

外循环，将i定义为终点，然后令j从0开始循环，找到最长的子序列

```
for(int i = 0; i < n ;i++)
{
	for (int j = 0 ; j < i; j++)
	{
		if(check(i ,j)) 
        	return i - j + 1;
	}
}
```

双指针做法：

1. 首先定义一个存储[j,i]区间段中不同元素的哈希表
2. 每次新的a[i]加入的话，就让s[a[i]] ++;
3. 由于只有每次新加入的a[i]才有可能让原序列成为含重复数的情况，故check（）函数可以写成s[a[i]] > 1，说明有两个相同的元素时，令s[a[j]]--，弹出元素，并移动j，j++，直到s[a[j]] < 1

##### C++代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int a[N];
int s[N]; //用于存储区间[j,i]之间不同值的个数，本质上是哈希表

int main()
{
    int n;
    cin >> n;
    int res = 0;
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    for(int i = 0, j = 0; i < n; i++)
    {
        
        s[a[i]] ++ ; //将a[i]置入哈希表中
        while(s[a[i]] > 1) //说明有重复值
        {
            s[a[j]] -- ; //对应a[j]元素弹出对应的元素
            j ++ ;
        }
        res = max(res, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```



#### 双区间双指针



题目描述：

给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。

数组下标从 0 开始。

请你求出满足 A[i]+B[j]=x 的数对 (i,j)。

数据保证有唯一解。



输入格式：

第一行包含三个整数 n,m,x，分别表示 A 的长度，B 的长度以及目标值 x。

第二行包含 n 个整数，表示数组 A。

第三行包含 m 个整数，表示数组 B。



输出格式：

共一行，包含两个整数 i 和 j。



数据范围：

数组长度不超过 1e5
同一数组内元素各不相同。
1≤数组元素≤1e9



输入样例：

```
4 5 6
1 2 4 7
3 4 6 8 9
```



输出样例：

```
1 1
```



##### 分析以及思路

朴素做法：

1. 对i，j分别进行循环，判断条件即可

```
for(int i = 0; i < n; i++)
	for(int j = 0; j< m ;j++)
		if(a[i] + b[j] == x) 
			输出i,j
```

双指针做法

由于A，B是有序序列，那么我们可以想办法让B从右往左只扫一遍，如何实现呢？

很简单，只要让a[i] + b[j] 第一个 <= x的情况让j停下来，判断一下a[i] + b[j]是否等于x，如果不是，则让i增加，这样由于b[j]之后的元素都大于b[j]，相加肯定大于x不需要考虑，只要考虑当前的i，j即可，这样就只要让j一直往前走即可。

##### C++代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int a[N];
int b[N];

int main()
{
    int n, m, x;
    cin >> n >> m >> x;
    for (int i = 0; i < n ; i++) scanf("%d", &a[i]);
    for (int i = 0; i < m ; i++) scanf("%d", &b[i]);
    
    for(int i = 0, j = m - 1; i < n ; i ++)
    {
        while( j >= 0 && a[i] + b[j] > x)
            j--;
        if(a[i] + b[j] == x)
        {
            cout << i << " " << j <<endl;
            break;
        }
    }
    return 0;
}
```

今日总结：看的东西太少了，需要反思，就酱紫~