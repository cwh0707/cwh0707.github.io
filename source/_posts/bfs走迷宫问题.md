---
title: bfs走迷宫问题
mathjax: true
tags:
  - Acwing
categories:
  - Acwing
  - BFS
abbrlink: 25805
date: 2021-11-15 07:57:12
---

#### 题目大意

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1) 处和 (n,m) 处的数字为 0，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1≤n,m≤100

#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```

#### 算法思路：

由于是需要求出最短路径，可以很容易地发现每条边的权值为1，可以很快地想到使用bfs，考虑这里是一个二维数组，在数据的存储上可能会有点差错，在这里为了熟悉模拟队列的操作，选择使用数组来模拟队列，只需要一个数组，一个队首指针hh和一个队尾tt即可，

bfs是具有模板的(概括一下)如下所示:

```c++
void bfs()
{
    //初始化状态，刚开始队列为空，先将第一个元素放进队列中去,并让指针指向队列的下一个元素
    
    while(hh <= tt) //当队列不为空时
    {
     	//取出队首元素
        //判断对应的条件
        //如果为true，那么将该元素置入队尾，并且将队尾指针往后移
    }
}
```

具体代码实现如下：

```c++
#include <iostream>
#include <algorithm> //pair
#include <cstring> //memset 

using namespace std;

const int N = 110;

typedef pair<int,int> PII;

//定义一个队列
PII q[N * N];
// 队首和队尾
int hh,tt;

int n,m;
int g[N][N];
//存储每个点到（0,0）的距离distance
int d[N][N];

int bfs()
{
    //初始化条件
    memset(d, -1, sizeof d);
    // 将原点放入到队首
    q[0] = {0,0};
    d[0][0] = 0;
    
    // 存储上下左右四个方向
    int dx[4] = {-1, 0, 0, 1};
    int dy[4] = {0, 1, -1, 0};
    
    while(hh <= tt)   //当队列不为空时
    {
        PII t = q[hh ++];  //取出队首元素
        for(int i=0;i<4;i++)
        {
            int x = t.first + dx[i];
            int y = t.second + dy[i];
            //如果该处没有使用过 并且走的通的话
            if(x >= 0 && x < n && y >= 0 && y < m && d[x][y] == -1 && g[x][y] == 0)
            {
                d[x][y] = d[t.first][t.second] + 1;
                q[++ tt] = {x, y}; //将对应元素加入队列
            }
        }
    }
    return d[n-1][m-1];
}


int main()
{
    cin >> n >> m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            scanf("%d",&g[i][j]);
            
    cout << bfs() << endl;
    return 0;
}
```

ps：（也可以使用stl的queue来实现，会比数组模拟会好理解的多，明天再补，不能熬夜~，就酱紫）