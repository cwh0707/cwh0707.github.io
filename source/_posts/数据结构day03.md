---
title: 数据结构day03
mathjax: true
tags:
  - 大整数乘法
  - 大整数除法
  - 前缀和
  - 差分
categories:
  - 数据结构与算法
abbrlink: 1107
date: 2021-12-16 07:05:30
---

## 前缀和与差分

### 前缀和

> 首先我们需要了解什么是前缀和
>
> 假设有一个数组：a[1],a[2]...a[i]
>
> 那么它的前缀和数组就是:s[i] =  a[1] + a[2] + ... + a[i]
>
> 注意：在前缀和与差分中没有使用下标为0的情况，用以减少判断条件

需要解决的问题：

<!--more-->

+ 如何计算前缀和数组S[i]？
+ 这个前缀和思想可以应用在什么地方？

前缀和使用的场景只有一个，可以快速计算该数组某个区间段[l,r]之间的和，O（1）的复杂度

好像之后会学到的树状数组获取区间dp优化的时候可能会用上，到时候碰到再说。

PS：前缀和并非是一个算法，只能说是一种思想，把它当做一个公式来看就好

---



问题描述：

输入一个长度为 n 的整数序列。

接下来再输入 m 个询问，每个询问输入一对 l,r。

对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。



输入格式：

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

接下来 m 行，每行包含两个整数 l和 r，表示一个询问的区间范围。



输出格式：

共 m 行，每行输出一个询问的结果。



数据范围：

1 ≤ l ≤ r ≤ n,
1 ≤ n,m ≤ 100000
−1000 ≤ 数列中元素的值 ≤ 1000



输入样例：

```
5 3
2 1 3 6 4
1 2
1 3
2 4
```



输出样例：

```
3
6
10
```

#### C++代码实现

```c
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int a[N],s[N];

int main()
{
    int n,m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for(int i = 1;i <= n; i++) s[i] = s[i-1] + a[i];
    while( m-- )
    {
        int l,r;
        cin >> l >> r;
        cout << s[r] - s[l-1] << endl;
    }
    return 0;
}
```

### 二维前缀和

> 将一维前缀和方法拓展了一下，可以用于计算子矩阵的整体和

---



问题描述：

输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。



输入格式：

第一行包含三个整数 n，m，q。

接下来 n 行，每行包含 m 个整数，表示整数矩阵。

接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。



输出格式：

共 q 行，每行输出一个询问的结果。



数据范围:

1≤n,m≤1000,
1≤q≤200000,
1≤x1≤x2≤n,
1≤y1≤y2≤m,
−1000≤矩阵内元素的值≤1000



输入样例：

```
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```



输出样例：

```
17
27
21
```

#### C++代码实现

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int a[N][N];
int s[N][N];

int main()
{
    int n,m,q;
    cin >> n >> m >> q;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m ;j++)
        {
            scanf("%d",&a[i][j]);
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];  //初始化s[i][j]
        }
    
    while( q-- )
    {
        int x1,y1,x2,y2;
        cin >> x1 >> y1 >> x2 >> y2;
        cout << s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] << endl;
    }
    return 0;
}
```

### 差分

> 差分与前缀和是一对逆运算，两者之间的关系相当于积分与微分一样
>
> 定义：假设我们有数组a[1],a[2],a[3],...a[i]
>
> 那么对应的差分数组b：b[1],b[2],b[3],...b[n]
>
> 满足a[i] = b[1] + b[2] + ... + b[i]
>
> 推导一下：
>
> ```
> b[1] = a[1]
> b[2] = a[2] - a[1]
> b[3] = a[3] - a[2]
> ...
> b[i] = a[i] - a[i-1]
> ```
>
> 可以很明显看出两者互为逆运算

但是有个问题，差分可以用来计算什么呢？

它的用处在于在O(1)的复杂度，使得a数组在[l,r]之间的数全部加上c

还有一个很nb的写法，就是我们输入的是a[]数组，我们如何使用上述方法得到b[]数组呢？可以将每位b[i]的输入设想成[i,i]区间插入a[i]，这个思路来计算，非常牛逼

---



#### 一阶差分

题目描述：

输入一个长度为 n 的整数序列。

接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。

请你输出进行完所有操作后的序列。



输入格式：

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数序列。

接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。



输出格式：

共一行，包含 n 个整数，表示最终序列。



数据范围：

1≤n,m≤100000,
1≤l≤r≤n,
−1000≤c≤1000,
−1000≤整数序列中元素的值≤1000



输入样例：

```
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```



输出样例：

```
3 4 5 3 4 2
```



#### C++代码实现

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int a[N], b[N]; // b存储的差分数组

//在区间[l,r]之间的数全部加上c
void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    
    for(int i = 1; i <= n; i++) insert(i, i, a[i]);
    
    while( m-- )
    {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }
    //输出对应的a数组 b数组的前缀和就是a数组
    for(int i = 1; i <= n; i++) 
    {
        b[i] += b[ i-1 ];
        cout << b[i] << " ";
    }
    cout <<endl;
    return 0;
    
}
```



#### 差分矩阵

题目描述：

输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。

每个操作都要将选中的子矩阵中的每个元素的值加上 c。

请你将进行完所有操作后的矩阵输出。



输入格式

第一行包含整数 n,m,q。

接下来 n 行，每行包含 m 个整数，表示整数矩阵。

接下来 q 行，每行包含 5个整数 x1,y1,x2,y2,c，表示一个操作。



输出格式

共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。



数据范围

1≤n,m≤1000
1≤q≤100000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤c≤1000
−1000≤矩阵内元素的值≤1000



输入样例：

```
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```



输出样例：

```
2 3 4 1
4 3 4 1
2 2 2 2
```



#### C++代码实现

难点在于：

insert函数构造，数学推导hh，可以自己画个矩阵来验算一下

其中b[][]矩阵是我们构造出来的差分矩阵，它的前缀和就是a矩阵

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int a[N][N];
int b[N][N];

void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j<= m; j++)
            insert(i, j, i, j, a[i][j]);

    while( q-- )
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }

    for(int i = 1; i<= n; i++)
    {
        for(int j = 1; j <= m ;j++)
        {
            b[i][j] += b[i - 1][j] + b[i][j-1] - b[i-1][j-1];
            cout << b[i][j] <<  " ";
        }
        cout << endl;
    }
    return 0;
}
```

