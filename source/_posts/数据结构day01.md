---
title: 数据结构day01
mathjax: true
tags:
  - 数据结构与算法
  - 快速排序
  - 归并排序
categories:
  - 数据结构与算法
abbrlink: 50642
date: 2021-12-14 07:29:02
---

## 排序

### 快速排序 

> 主要思想：分治法

#### 算法描述：

1. 先找一个分界点x，这个分界点可左，可右，可中间，也可以是随机一个位置

   即对应为q[l],q[r],q[l+r>>1],random(q)

2. 调整区间 (算法中最难的部分)

   x在左边的数都小于x

   x在右边的数都大于x

3. 递归处理左右两段

<!--more-->

trick：如何优雅第完成第2步？

先给一种常规的思路来说：

+ 创建两个数组a[],b[]
+ 扫描q[l~r]，当q[i] < x 置入a数组；当q[i] > x则置入b数组
+ a[] 放到 q[]; b[ ] 放到 q[];

然后在给出一种双指针的优美写法：

> 用两个指针在首尾两头
>
> i从左边往右边扫，当前i指向的元素小于x时，i++，知道碰到大于x的元素
>
> 然后j往左走，当前j指向的元素如何大于x时，j--，直到碰到小于x的元素
>
> 交换i，j指向的元素，并i++，j--
>
> 重复上述操作，知道 i > j 
>
> 注意：停止状态时时 i > j，可以带个样例试试

---



题目描述：

给定你一个长度为 n 的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。



输入格式：

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼1e9 范围内），表示整个数列。



输出格式：

输出共一行，包含 n 个整数，表示排好序的数列。



数据范围：

1 ≤ n ≤ 100000



输入样例：

```
5
3 1 2 4 5
```



输出样例：

```
1 2 3 4 5
```

#### C++代码

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int q[N];  //存放待排序的数据

void quicksort(int q[],int l, int r)
{
    if (l >= r) return ; //说明已经到达最小的结点

    int x = q[(l + r) >> 1];  //取中间值
    int i = l - 1;
    int j = r + 1;
    while( i < j)
    {
        do i ++; while(q[i] < x);
        do j --; while(q[j] > x);
        if(i < j) swap(q[i],q[j]); //交换两个指针对应元素的值
    }
    //在这边解释一下为什么选用j和j+1，在模拟了一次样例发现退出循环的时候i和j是错位的也就是说在i > j的时候退出的循环
    //那么就可以认为j在i的左边，划分区间的时候可以左边取j右边取j+1
    quicksort(q,l,j);
    quicksort(q,j+1,r);
}

int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 0;i < n; i++) scanf("%d", &q[i]);

    quicksort(q, 0, n-1);
    for(int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```

### 归并排序

#### 算法描述

> 主要思想：分治法

那么问题来了，归并和快排都是分治思想，它们之间有什么区别呢？

快排是对一个元素x来分的，而归并则是基于位置来分的

快排的平均复杂度是O(nlogn)，最坏情况为O(n^2),归并排序的复杂度是严格O(nlogn)

算法步骤：

1. 确定分界点 mid = l + r >> 1;
2. 递归处理左边区间，右边区间
3. 归并，把两个有序的序列合而为一（这一步最难也最核心）

trick：如何优雅地实现第三步呢？

+ 首先a，b两个有序序列，都有一个头指针，那么这个指针指向的元素就是对应序列中最小的那个值
+ 两者比较一下大小，将小的那个元素的值放入一个新的数组res中，并让对应的指针后移
+ 直到有一个指针指向了末尾的时候，这时候可能会有另一个序列还没放完，很简单将那个序列后面的部分都放到那个res数组中，排序完成

---

题目描述：

给定你一个长度为 n 的整数数列。

请你使用归并排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。



输入格式：

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼1e9 范围内），表示整个数列。



输出格式：

输出共一行，包含 n 个整数，表示排好序的数列。



数据范围：

1 ≤ n ≤ 100000



输入样例：

```
5
3 1 2 4 5
```



输出样例：

```
1 2 3 4 5
```

#### C++代码

```c++
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int q[N];
//由于归并排序需要额外开一个空间用来保存结果
int tmp[N];


void mergesort(int q[], int l, int r)
{
    if(l >= r) return ;  //当结点中只有一个结点的时候

    int mid = (l + r) >> 1; // +的优先级大于 右移 >>
    mergesort(q, l, mid);
    mergesort(q, mid+1, r);

    //进行归并操作
    int i = l, j = mid + 1;
    int k = 0; //用于保存tmp中已经有多少个数 不能放在循环外
    while( i <= mid && j <= r)
    {
        if(q[i] < q[j]) tmp[ k++ ] = q[ i++ ];
        else tmp[ k++ ] = q[ j++ ];
    }
    while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];

    //最后记得将tmp结果返回给q
    for(int i = l, j = 0; i <= r; i++,j++) q[i] = tmp[j];
}

int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    mergesort(q, 0, n-1);
    for(int i = 0; i< n; i++) printf("%d ", q[i]);
    return 0;
}
```